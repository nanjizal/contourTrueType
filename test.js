// Generated by Haxe 4.3.0-rc.1+5f599ba
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var cornerContour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.endCapFactor = 0.5;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_Contour.__name__ = true;
cornerContour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var smallest = theta <= Math.PI;
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3 || this.endLine == 6 || this.endLine == 8 || this.endLine == 11 || this.endLine == 9 || this.endLine == 15 || this.endLine == 17 || this.endLine == 12 || this.endLine == 14 || this.endLine == 18 || this.endLine == 20)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			this.startShape(ax,ay,width_ / 2,beta,gamma,fracs_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(this.count == 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var temp = [];
			this.startShape(ax,ay,width_ / 2,beta,gamma,fracs_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0 && (this.endLine == 2 || this.endLine == 3 || this.endLine == 7 || this.endLine == 8 || this.endLine == 11 || this.endLine == 10 || this.endLine == 16 || this.endLine == 17 || this.endLine == 13 || this.endLine == 14 || this.endLine == 19 || this.endLine == 20)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var ddx = ax1 + radius * Math.sin(angle);
			var ddy = ay1 + radius * Math.cos(angle);
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var color_1 = color;
								if(color_1 == null) {
									color_1 = -1;
								}
								this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
							}
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this4 = this.endLine;
					if(this4 == 13 || this4 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
		if(this.count != 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var ddx = ax1 + radius * Math.sin(angle);
			var ddy = ay1 + radius * Math.cos(angle);
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var color_1 = color;
								if(color_1 == null) {
									color_1 = -1;
								}
								this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
							}
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this4 = this.endLine;
					if(this4 == 13 || this4 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,-1);
			}
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,-1);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,-1);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,-1);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 4:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 5:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 6:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 7:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 8:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 9:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 10:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 11:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 12:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 13:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 14:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 15:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 16:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 17:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 18:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 19:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 20:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
	,startShape: function(ax,ay,radius,beta,gamma,prefer,edgePoly,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var f;
			if(beta >= 0 && beta > Math.PI) {
				f = beta;
			} else {
				var a = beta % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(gamma >= 0 && gamma > Math.PI) {
				f = gamma;
			} else {
				var a = gamma % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 18 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 12 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
			fy = ay - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
			radius *= 2;
			delta = Math.pow(radius / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 12 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 18 || this2 == 20) {
						var ry = this.endCapFactor * radius;
						cx = ax + radius * Math.sin(angle);
						cy = ay + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax;
						cy -= ay;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax;
						cy += ay;
					} else {
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
					}
				}
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
					var this3 = this.endLine;
					if(this3 == 12 || this3 == 14) {
						var deltaG = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
						var deltaE = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
						if(deltaE > delta || deltaG > delta) {
							var color_1 = color;
							if(color_1 == null) {
								color_1 = -1;
							}
							this.pen.triangle2DFill(ax,ay,gx,gy,ex,ey,color_1);
						}
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this4 = this.endLine;
				if(this4 == 12 || this4 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 9 || this1 == 11) {
				angle = beta;
				var ddx = ax - radius * this.endCapFactor * Math.sin(angle);
				var ddy = ay - radius * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * this.endCapFactor * Math.sin(angle);
				cy = ay - radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * this.endCapFactor * Math.sin(angle);
				cy = ay + radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			} else {
				var this1 = this.endLine;
				if(this1 == 6 || this1 == 8) {
					angle = beta;
					var ddx = ax - radius * Math.sin(angle);
					var ddy = ay - radius * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 15 || this1 == 17) {
						angle = beta;
						var ddx = ax - radius * this.endCapFactor * Math.sin(angle);
						var ddy = ay - radius * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ddx - 2 * radius * this.endCapFactor * Math.sin(angle);
						cy = ddy - 2 * radius * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax + radius * this.endCapFactor * Math.sin(angle);
						ey = ay + radius * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
					}
				}
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
};
var cornerContour_Pen2D = function(col) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	this.currentColor = col;
};
cornerContour_Pen2D.__name__ = true;
cornerContour_Pen2D.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.fill = false;
	this.rotation = 0.;
	this.penIsDown = true;
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.rotation = -Math.PI / 2;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
cornerContour_Sketcher.__name__ = true;
cornerContour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 31, className : "cornerContour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 31, className : "cornerContour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new cornerContour_Contour(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
};
var cornerContour_io_Array2DTriangles = {};
cornerContour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
cornerContour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
cornerContour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
cornerContour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
cornerContour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
cornerContour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
cornerContour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_color = function(this1) {
	return this1[(this1[0] | 0) * 7 + 6 + 1];
};
cornerContour_io_Array2DTriangles.set_colorInt = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 7 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
	cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
	cornerContour_io_Array2DTriangles.set_bx(this1,bx_);
	cornerContour_io_Array2DTriangles.set_by(this1,by_);
	cornerContour_io_Array2DTriangles.set_cx(this1,cx_);
	cornerContour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
		cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
		cornerContour_io_Array2DTriangles.set_bx(this1,cx_);
		cornerContour_io_Array2DTriangles.set_by(this1,cy_);
		cornerContour_io_Array2DTriangles.set_cx(this1,bx_);
		cornerContour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriangles.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_by(this1) - cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) + (cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_cy(this1) - cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_by(this1)) + (cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) - cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_cy(this1)) > 0;
};
var cornerContour_io_ColorTriangles2D = {};
cornerContour_io_ColorTriangles2D.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 18 + 2];
};
cornerContour_io_ColorTriangles2D.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 18 + 1 + 2];
};
cornerContour_io_ColorTriangles2D.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 1 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 2 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 18 + 6 + 2];
};
cornerContour_io_ColorTriangles2D.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 6 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_by = function(this1) {
	return this1[(this1[0] | 0) * 18 + 7 + 2];
};
cornerContour_io_ColorTriangles2D.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 7 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 8 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 18 + 12 + 2];
};
cornerContour_io_ColorTriangles2D.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 12 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 18 + 13 + 2];
};
cornerContour_io_ColorTriangles2D.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 13 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 14 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_ColorTriangles2D.set_ax(this1,ax_);
	cornerContour_io_ColorTriangles2D.set_ay(this1,ay_);
	cornerContour_io_ColorTriangles2D.set_bx(this1,bx_);
	cornerContour_io_ColorTriangles2D.set_by(this1,by_);
	cornerContour_io_ColorTriangles2D.set_cx(this1,cx_);
	cornerContour_io_ColorTriangles2D.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_ColorTriangles2D.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_ColorTriangles2D.set_ax(this1,ax_);
		cornerContour_io_ColorTriangles2D.set_ay(this1,ay_);
		cornerContour_io_ColorTriangles2D.set_bx(this1,cx_);
		cornerContour_io_ColorTriangles2D.set_by(this1,cy_);
		cornerContour_io_ColorTriangles2D.set_cx(this1,bx_);
		cornerContour_io_ColorTriangles2D.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_ColorTriangles2D.adjustWinding = function(this1) {
	return cornerContour_io_ColorTriangles2D.get_ax(this1) * cornerContour_io_ColorTriangles2D.get_by(this1) - cornerContour_io_ColorTriangles2D.get_bx(this1) * cornerContour_io_ColorTriangles2D.get_ay(this1) + (cornerContour_io_ColorTriangles2D.get_bx(this1) * cornerContour_io_ColorTriangles2D.get_cy(this1) - cornerContour_io_ColorTriangles2D.get_cx(this1) * cornerContour_io_ColorTriangles2D.get_by(this1)) + (cornerContour_io_ColorTriangles2D.get_cx(this1) * cornerContour_io_ColorTriangles2D.get_ay(this1) - cornerContour_io_ColorTriangles2D.get_ax(this1) * cornerContour_io_ColorTriangles2D.get_cy(this1)) > 0;
};
var cornerContour_io_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
cornerContour_io_IntIterStart.__name__ = true;
var cornerContour_web_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
cornerContour_web_DivertTrace.__name__ = true;
cornerContour_web_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var cornerContour_web_Renderer_$ = function(gl,pen,width,height) {
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.gl = gl;
	this.pen = pen;
	this.width = width;
	this.height = height;
};
cornerContour_web_Renderer_$.__name__ = true;
var cornerContour_web_Sheet = function() {
};
cornerContour_web_Sheet.__name__ = true;
cornerContour_web_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var cornerContourWebGLTest_CornerContourWebGL = function() {
	this.theta = 0.;
	this.allRange = [];
	this.divertTrace = new cornerContour_web_DivertTrace();
	haxe_Log.trace("Contour Test",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL.js.hx", lineNumber : 68, className : "cornerContourWebGLTest.CornerContourWebGL", methodName : "new"});
	this.width = 1024;
	this.height = 768;
	this.mainSheet = new cornerContour_web_Sheet();
	this.mainSheet.create(this.width,this.height,true);
	this.gl = this.mainSheet.gl;
	this.initContours();
	this.renderer = new cornerContour_web_Renderer_$(this.gl,this.pen2D,this.width,this.height);
	this.draw();
	var this1 = this.renderer;
	var data = this1.pen.arr;
	this1.totalTriangles = (data.length - 1) / 7 | 0;
	this1.bufferLength = this1.totalTriangles * 3;
	this1.triSize = 18;
	this1.len = this1.totalTriangles * this1.triSize | 0;
	var this2 = new Float32Array(this1.len + 2);
	var this3 = this2;
	this3[0] = 0.;
	this3[1] = 0.;
	var this2 = this3;
	var this3 = this2;
	var this2 = this3;
	this1.arrData = this2;
	var _g = 0;
	var _g1 = this1.totalTriangles;
	while(_g < _g1) {
		var i = _g++;
		this1.pen.arr[0] = i;
		var this2 = this1.arrData;
		this2[0] = i;
		if(this2[0] > this2[1] - 1) {
			this2[1] = this2[0];
		}
		var this3 = this1.arrData;
		var col = cornerContour_io_Array2DTriangles.get_color(data) | 0;
		cornerContour_io_ColorTriangles2D.set_redA(this3,(col >> 16 & 255) / 255);
		var v = (col & 255) / 255;
		this3[(this3[0] | 0) * 18 + 4 + 2] = v;
		var v1 = (col >> 8 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 3 + 2] = v1;
		var v2 = (col >> 24 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 5 + 2] = v2;
		cornerContour_io_ColorTriangles2D.set_redB(this3,(col >> 16 & 255) / 255);
		var v3 = (col & 255) / 255;
		this3[(this3[0] | 0) * 18 + 10 + 2] = v3;
		var v4 = (col >> 8 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 9 + 2] = v4;
		var v5 = (col >> 24 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 11 + 2] = v5;
		cornerContour_io_ColorTriangles2D.set_redC(this3,(col >> 16 & 255) / 255);
		var v6 = (col & 255) / 255;
		this3[(this3[0] | 0) * 18 + 16 + 2] = v6;
		var v7 = (col >> 8 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 15 + 2] = v7;
		var v8 = (col >> 24 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 17 + 2] = v8;
		cornerContour_io_ColorTriangles2D.set_ax(this1.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_ax(data) / this1.width));
		cornerContour_io_ColorTriangles2D.set_ay(this1.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_ay(data) / this1.height);
		cornerContour_io_ColorTriangles2D.set_bx(this1.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_bx(data) / this1.width));
		cornerContour_io_ColorTriangles2D.set_by(this1.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_by(data) / this1.height);
		cornerContour_io_ColorTriangles2D.set_cx(this1.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_cx(data) / this1.width));
		cornerContour_io_ColorTriangles2D.set_cy(this1.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_cy(data) / this1.height);
	}
	var this1 = this.renderer;
	var gl = this1.gl;
	var program = gl.createProgram();
	var shader = gl.createShader(35633);
	gl.shaderSource(shader,"attribute vec2 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, .0, 1.0);" + " vcol = vertexColor;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	var shader = gl.createShader(35632);
	gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + "vec4 color = vec4(vcol.rgb, 1. );" + "color *= vcol.a; " + "gl_FragColor = color;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	gl.linkProgram(program);
	var tmp;
	if(!gl.getProgramParameter(program,35714)) {
		throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
	} else {
		gl.validateProgram(program);
		if(!gl.getProgramParameter(program,35715)) {
			throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
		} else {
			gl.useProgram(program);
			tmp = program;
		}
	}
	this1.program = tmp;
	this1.gl.bindBuffer(34962,null);
	this1.gl.useProgram(this1.program);
	var this2 = this1.arrData;
	var arr = this2.subarray(2,(this2[1] | 0) * 18 + 2);
	var gl = this1.gl;
	var program = this1.program;
	var xyName = this1.vertexPosition;
	var rgbaName = this1.vertexColor;
	var isDynamic = true;
	if(isDynamic == null) {
		isDynamic = false;
	}
	var isDynamic1 = isDynamic;
	if(isDynamic1 == null) {
		isDynamic1 = false;
	}
	var buf = gl.createBuffer();
	var staticDraw = 35044;
	var dynamicDraw = 35048;
	var arrayBuffer = 34962;
	gl.bindBuffer(arrayBuffer,buf);
	if(isDynamic1) {
		var arrayBuffer = 34962;
		gl.bufferData(arrayBuffer,arr,dynamicDraw);
	} else {
		var arrayBuffer = 34962;
		gl.bufferData(arrayBuffer,arr,staticDraw);
	}
	var vbo = buf;
	var inp = gl.getAttribLocation(program,xyName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 0 * elementBytes;
	gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	var inp = gl.getAttribLocation(program,rgbaName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 2 * elementBytes;
	gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	this1.buf = vbo;
	this1.gl.bindBuffer(34962,this1.buf);
	this1.gl.useProgram(this1.program);
	var gl = this1.gl;
	var program = this1.program;
	var rgbaName = this1.vertexColor;
	var inp = gl.getAttribLocation(program,this1.vertexPosition);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 0 * elementBytes;
	gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	var inp = gl.getAttribLocation(program,rgbaName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 2 * elementBytes;
	gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	this1.gl.bindBuffer(34962,this1.buf);
	var this2 = this1.arrData;
	this1.currData = this2.subarray(2,(this2[1] | 0) * 18 + 2);
	var _gthis = this;
	if(htmlHelper_tools_AnimateTimer.s == null) {
		htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
		htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
		window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
		htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
		htmlHelper_tools_AnimateTimer.loop(60.0);
	}
	htmlHelper_tools_AnimateTimer.onFrame = function(v) {
		var _g = 0;
		var _g1 = _gthis.allRange;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			var this1 = _gthis.renderer.arrData;
			var dy = 0.0004 * Math.sin(_gthis.theta);
			var temp = this1[0];
			var _g_min = i.start;
			var _g_max = i.max;
			while(_g_min < _g_max) {
				var i1 = _g_min++;
				this1[0] = i1;
				if(this1[0] > this1[1] - 1) {
					this1[1] = this1[0];
				}
				cornerContour_io_ColorTriangles2D.set_ax(this1,cornerContour_io_ColorTriangles2D.get_ax(this1));
				cornerContour_io_ColorTriangles2D.set_ay(this1,cornerContour_io_ColorTriangles2D.get_ay(this1) + dy);
				cornerContour_io_ColorTriangles2D.set_bx(this1,cornerContour_io_ColorTriangles2D.get_bx(this1));
				cornerContour_io_ColorTriangles2D.set_by(this1,cornerContour_io_ColorTriangles2D.get_by(this1) + dy);
				cornerContour_io_ColorTriangles2D.set_cx(this1,cornerContour_io_ColorTriangles2D.get_cx(this1));
				cornerContour_io_ColorTriangles2D.set_cy(this1,cornerContour_io_ColorTriangles2D.get_cy(this1) + dy);
			}
			this1[0] = temp;
			if(this1[0] > this1[1] - 1) {
				this1[1] = this1[0];
			}
			var this2 = _gthis.renderer.arrData;
			var t = Math.cos(_gthis.theta);
			var temp1 = this2[0];
			var _g_min1 = i.start;
			var _g_max1 = i.max;
			while(_g_min1 < _g_max1) {
				var i2 = _g_min1++;
				this2[0] = i2;
				if(this2[0] > this2[1] - 1) {
					this2[1] = this2[0];
				}
				var smooth = true;
				if(smooth == null) {
					smooth = true;
				}
				var r = 1.;
				var g = 0.;
				var b = 0.;
				var a = 1.;
				var r2 = 0.0588235294117647051;
				var g2 = 1.;
				var b2 = 0.;
				var a2 = 1.;
				var v = smooth ? t * t * t * (t * (t * 6.0 - 15.0) + 10.0) : t;
				cornerContour_io_ColorTriangles2D.set_redA(this2,r + v * (r2 - r));
				var v1 = b + v * (b2 - b);
				this2[(this2[0] | 0) * 18 + 4 + 2] = v1;
				var v2 = g + v * (g2 - g);
				this2[(this2[0] | 0) * 18 + 3 + 2] = v2;
				var v3 = a + v * (a2 - a);
				this2[(this2[0] | 0) * 18 + 5 + 2] = v3;
				cornerContour_io_ColorTriangles2D.set_redB(this2,r + v * (r2 - r));
				var v4 = b + v * (b2 - b);
				this2[(this2[0] | 0) * 18 + 10 + 2] = v4;
				var v5 = g + v * (g2 - g);
				this2[(this2[0] | 0) * 18 + 9 + 2] = v5;
				var v6 = a + v * (a2 - a);
				this2[(this2[0] | 0) * 18 + 11 + 2] = v6;
				cornerContour_io_ColorTriangles2D.set_redC(this2,r + v * (r2 - r));
				var v7 = b + v * (b2 - b);
				this2[(this2[0] | 0) * 18 + 16 + 2] = v7;
				var v8 = g + v * (g2 - g);
				this2[(this2[0] | 0) * 18 + 15 + 2] = v8;
				var v9 = a + v * (a2 - a);
				this2[(this2[0] | 0) * 18 + 17 + 2] = v9;
			}
			this2[0] = temp1;
			if(this2[0] > this2[1] - 1) {
				this2[1] = this2[0];
			}
			_gthis.theta += 30 * Math.PI / 180;
		}
		_gthis.theta += Math.PI / 180;
		var this1 = _gthis.renderer;
		var this2 = this1.arrData;
		this1.currData = this2.subarray(2,(this2[1] | 0) * 18 + 2);
		var gl = _gthis.gl;
		var width = _gthis.width;
		var height = _gthis.height;
		var r = 0.;
		var g = 0.;
		var b = 0.;
		var a = 1.;
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		gl.clearColor(r,g,b,a);
		gl.enable(2929);
		gl.clear(16384);
		gl.viewport(0,0,width,height);
		gl.enable(3042);
		gl.blendFunc(1,771);
		gl.enable(2884);
		var this1 = _gthis.renderer;
		var ii_min = _gthis.allRange[0].start;
		var ii_max = _gthis.allRange[_gthis.allRange.length - 1].max;
		var this2 = new cornerContour_io_IntIterStart(ii_min,ii_max);
		var range = this2;
		var partData = this1.currData.subarray(range.start * this1.triSize,range.max * this1.triSize);
		this1.gl.bufferSubData(34962,0,partData);
		this1.gl.useProgram(this1.program);
		this1.gl.drawArrays(4,0,(range.max - range.start) * 3 | 0);
	};
};
cornerContourWebGLTest_CornerContourWebGL.__name__ = true;
cornerContourWebGLTest_CornerContourWebGL.prototype = {
	parseFont: function() {
		var bytes = haxe_Resource.getBytes("font");
		var bytesInput = new haxe_io_BytesInput(bytes);
		var ttfReader = new format_ttf_Reader(bytesInput);
		var ttf = ttfReader.read();
		var fontUtils = new truetype_TTFGlyphUtils(ttf);
		var str = "The quick brown fox jumps over the lazy dog.";
		var haxeLetters = str.split("");
		var space = 0.;
		var y2 = 0.;
		var displayScale = 0.5;
		var _g = 0;
		while(_g < haxeLetters.length) {
			var letter = haxeLetters[_g];
			++_g;
			space += this.displayGlyph(HxOverrides.cca(letter,0) - 28,fontUtils,displayScale,space,y2);
			if(space > 500 && letter == " ") {
				space = 0;
				y2 += 80 * displayScale;
			}
		}
	}
	,displayGlyph: function(index,utils,displayScale,space,y2) {
		if(y2 == null) {
			y2 = 0;
		}
		if(space == null) {
			space = 0.;
		}
		if(displayScale == null) {
			displayScale = 4.;
		}
		var glyph = utils.getGlyphSimple(index);
		if(glyph == null) {
			return 20 * displayScale;
		}
		var glyphHeader = utils.getGlyphHeader(index);
		var contours = utils.getGlyphContours(index);
		var scale = 64 / utils.headdata.unitsPerEm * displayScale;
		var x = 516 * scale + space;
		var y = 100 + y2;
		var dy = utils.headdata.yMax;
		var maxX = 0.;
		var s = this.pen2D.arr[0] | 0;
		var _g = 0;
		while(_g < contours.length) {
			var contour = contours[_g];
			++_g;
			var newX = this.drawContour(contour,x,y,scale) - x + displayScale * 5;
			if(maxX < newX) {
				maxX = newX;
			}
		}
		var tmp = this.allRange;
		var ii_min = s;
		var ii_max = this.pen2D.arr[0] - 1 | 0;
		var this1 = new cornerContour_io_IntIterStart(ii_min,ii_max);
		tmp.push(this1);
		return maxX;
	}
	,drawContour: function(contour,x,y,scale) {
		var offCurvePoint = null;
		var ax;
		var ay;
		var bx;
		var by;
		var maxX = 0.;
		var _g = 0;
		var _g1 = contour.length;
		while(_g < _g1) {
			var i = _g++;
			var point = contour[i];
			if(i == 0) {
				ax = scale * point.x + x;
				ay = -scale * point.y + y;
				if(maxX < ax) {
					maxX = ax;
				}
				var _this = this.sketcher;
				var tmp;
				switch(_this.endLine) {
				case 0:case 1:case 6:case 9:case 12:case 15:case 18:
					tmp = false;
					break;
				case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
					tmp = true;
					break;
				}
				if(tmp) {
					_this.contour.end(_this.width);
				}
				_this.x = ax;
				_this.y = ay;
				var l = _this.points.length;
				_this.points[l] = [];
				_this.points[l][0] = ax;
				_this.points[l][1] = ay;
				_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
				_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
				_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this.dim[_this.dim.length - 1];
				if(ax < d.minX) {
					d.minX = ax;
				}
				if(ax > d.maxX) {
					d.maxX = ax;
				}
				if(ay < d.minY) {
					d.minY = ay;
				}
				if(ay > d.maxY) {
					d.maxY = ay;
				}
				_this.contour.reset();
			} else {
				var prevPoint = contour[i - 1];
				if(point.onCurve) {
					if(prevPoint.onCurve) {
						ax = scale * point.x + x;
						ay = -scale * point.y + y;
						if(maxX < ax) {
							maxX = ax;
						}
						this.sketcher.lineTo(ax,ay);
					} else {
						ax = scale * offCurvePoint.x + x;
						ay = -scale * offCurvePoint.y + y;
						if(maxX < ax) {
							maxX = ax;
						}
						bx = scale * point.x + x;
						by = -scale * point.y + y;
						if(maxX < bx) {
							maxX = bx;
						}
						var _this1 = this.sketcher;
						_this1.tempArr = [];
						var p = _this1.tempArr;
						var ax1 = _this1.x;
						var ay1 = _this1.y;
						var x1 = ax1 - ax;
						var y1 = ay1 - ay;
						var x2 = ax - bx;
						var y2 = ay - by;
						var approxDistance = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
						if(approxDistance == 0) {
							approxDistance = 0.000001;
						}
						var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
						var l1 = p.length;
						p[l1++] = ax1;
						p[l1++] = ay1;
						var t = step;
						while(t < 1.) {
							var u = 1 - t;
							p[l1++] = Math.pow(u,2) * ax1 + 2 * u * t * ax + Math.pow(t,2) * bx;
							var u1 = 1 - t;
							p[l1++] = Math.pow(u1,2) * ay1 + 2 * u1 * t * ay + Math.pow(t,2) * by;
							t += step;
						}
						p[l1++] = bx;
						p[l1++] = by;
						var arr = _this1.tempArr;
						var withMove = false;
						if(withMove == null) {
							withMove = true;
						}
						var l2 = arr.length;
						var i1 = 2;
						if(withMove) {
							var x_ = arr[0];
							var y_ = arr[1];
							var tmp1;
							switch(_this1.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp1 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp1 = true;
								break;
							}
							if(tmp1) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = x_;
							_this1.y = y_;
							var l3 = _this1.points.length;
							_this1.points[l3] = [];
							_this1.points[l3][0] = x_;
							_this1.points[l3][1] = y_;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d1 = _this1.dim[_this1.dim.length - 1];
							if(x_ < d1.minX) {
								d1.minX = x_;
							}
							if(x_ > d1.maxX) {
								d1.maxX = x_;
							}
							if(y_ < d1.minY) {
								d1.minY = y_;
							}
							if(y_ > d1.maxY) {
								d1.maxY = y_;
							}
							_this1.contour.reset();
						} else {
							_this1.lineTo(arr[0],arr[1]);
						}
						var cx = (arr[0] + arr[l2 - 2]) / 2;
						var cy = (arr[1] + arr[l2 - 1]) / 2;
						var ox = _this1.x;
						var oy = _this1.y;
						while(i1 < l2) {
							if(_this1.fill && _this1.penIsDown) {
								if(i1 > 0 && i1 < l2 - 2) {
									_this1.pen.triangle2DFill(arr[i1 - 2],arr[i1 - 1],arr[i1],arr[i1 + 1],cx,cy);
								}
							}
							_this1.lineTo(arr[i1],arr[i1 + 1]);
							i1 += 2;
						}
						if(_this1.fill && _this1.penIsDown) {
							var tmp2;
							switch(_this1.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp2 = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp2 = true;
								break;
							}
							if(tmp2) {
								_this1.contour.end(_this1.width);
							}
							_this1.x = ox;
							_this1.y = oy;
							var l4 = _this1.points.length;
							_this1.points[l4] = [];
							_this1.points[l4][0] = ox;
							_this1.points[l4][1] = oy;
							_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
							_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
							_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d2 = _this1.dim[_this1.dim.length - 1];
							if(ox < d2.minX) {
								d2.minX = ox;
							}
							if(ox > d2.maxX) {
								d2.maxX = ox;
							}
							if(oy < d2.minY) {
								d2.minY = oy;
							}
							if(oy > d2.maxY) {
								d2.maxY = oy;
							}
							_this1.contour.reset();
							_this1.lineTo(arr[l2 - 2],arr[l2 - 1]);
						}
						_this1.x = bx;
						_this1.y = by;
					}
				} else {
					offCurvePoint = contour[i];
				}
			}
		}
		return maxX;
	}
	,initContours: function() {
		this.pen2D = new cornerContour_Pen2D(-16776961);
		this.pen2D.currentColor = -1;
		this.sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		this.sketcher.width = 1;
	}
	,draw: function() {
		this.parseFont();
		var this1 = this.renderer;
		var data = this1.pen.arr;
		this1.totalTriangles = (data.length - 1) / 7 | 0;
		this1.bufferLength = this1.totalTriangles * 3;
		this1.triSize = 18;
		this1.len = this1.totalTriangles * this1.triSize | 0;
		var this2 = new Float32Array(this1.len + 2);
		var this3 = this2;
		this3[0] = 0.;
		this3[1] = 0.;
		var this2 = this3;
		var this3 = this2;
		var this2 = this3;
		this1.arrData = this2;
		var _g = 0;
		var _g1 = this1.totalTriangles;
		while(_g < _g1) {
			var i = _g++;
			this1.pen.arr[0] = i;
			var this2 = this1.arrData;
			this2[0] = i;
			if(this2[0] > this2[1] - 1) {
				this2[1] = this2[0];
			}
			var this3 = this1.arrData;
			var col = cornerContour_io_Array2DTriangles.get_color(data) | 0;
			cornerContour_io_ColorTriangles2D.set_redA(this3,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			this3[(this3[0] | 0) * 18 + 4 + 2] = v;
			var v1 = (col >> 8 & 255) / 255;
			this3[(this3[0] | 0) * 18 + 3 + 2] = v1;
			var v2 = (col >> 24 & 255) / 255;
			this3[(this3[0] | 0) * 18 + 5 + 2] = v2;
			cornerContour_io_ColorTriangles2D.set_redB(this3,(col >> 16 & 255) / 255);
			var v3 = (col & 255) / 255;
			this3[(this3[0] | 0) * 18 + 10 + 2] = v3;
			var v4 = (col >> 8 & 255) / 255;
			this3[(this3[0] | 0) * 18 + 9 + 2] = v4;
			var v5 = (col >> 24 & 255) / 255;
			this3[(this3[0] | 0) * 18 + 11 + 2] = v5;
			cornerContour_io_ColorTriangles2D.set_redC(this3,(col >> 16 & 255) / 255);
			var v6 = (col & 255) / 255;
			this3[(this3[0] | 0) * 18 + 16 + 2] = v6;
			var v7 = (col >> 8 & 255) / 255;
			this3[(this3[0] | 0) * 18 + 15 + 2] = v7;
			var v8 = (col >> 24 & 255) / 255;
			this3[(this3[0] | 0) * 18 + 17 + 2] = v8;
			cornerContour_io_ColorTriangles2D.set_ax(this1.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_ax(data) / this1.width));
			cornerContour_io_ColorTriangles2D.set_ay(this1.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_ay(data) / this1.height);
			cornerContour_io_ColorTriangles2D.set_bx(this1.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_bx(data) / this1.width));
			cornerContour_io_ColorTriangles2D.set_by(this1.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_by(data) / this1.height);
			cornerContour_io_ColorTriangles2D.set_cx(this1.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_cx(data) / this1.width));
			cornerContour_io_ColorTriangles2D.set_cy(this1.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_cy(data) / this1.height);
		}
		var this1 = this.renderer;
		var this2 = this1.arrData;
		this1.currData = this2.subarray(2,(this2[1] | 0) * 18 + 2);
	}
};
function cornerContourWebGLTest_CornerContourWebGL_main() {
	new cornerContourWebGLTest_CornerContourWebGL();
}
var format_ttf_MacGlyphNames = function() { };
format_ttf_MacGlyphNames.__name__ = true;
var format_ttf_Table = $hxEnums["format.ttf.Table"] = { __ename__:true,__constructs__:null
	,TGlyf: ($_=function(descriptions) { return {_hx_index:0,descriptions:descriptions,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TGlyf",$_.__params__ = ["descriptions"],$_)
	,THmtx: ($_=function(metrics) { return {_hx_index:1,metrics:metrics,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="THmtx",$_.__params__ = ["metrics"],$_)
	,TCmap: ($_=function(subtables) { return {_hx_index:2,subtables:subtables,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TCmap",$_.__params__ = ["subtables"],$_)
	,TKern: ($_=function(kerning) { return {_hx_index:3,kerning:kerning,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TKern",$_.__params__ = ["kerning"],$_)
	,TName: ($_=function(records) { return {_hx_index:4,records:records,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TName",$_.__params__ = ["records"],$_)
	,THead: ($_=function(data) { return {_hx_index:5,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="THead",$_.__params__ = ["data"],$_)
	,THhea: ($_=function(data) { return {_hx_index:6,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="THhea",$_.__params__ = ["data"],$_)
	,TLoca: ($_=function(data) { return {_hx_index:7,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TLoca",$_.__params__ = ["data"],$_)
	,TMaxp: ($_=function(data) { return {_hx_index:8,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TMaxp",$_.__params__ = ["data"],$_)
	,TPost: ($_=function(data) { return {_hx_index:9,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TPost",$_.__params__ = ["data"],$_)
	,TOS2: ($_=function(data) { return {_hx_index:10,data:data,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TOS2",$_.__params__ = ["data"],$_)
	,TUnkn: ($_=function(bytes) { return {_hx_index:11,bytes:bytes,__enum__:"format.ttf.Table",toString:$estr}; },$_._hx_name="TUnkn",$_.__params__ = ["bytes"],$_)
};
format_ttf_Table.__constructs__ = [format_ttf_Table.TGlyf,format_ttf_Table.THmtx,format_ttf_Table.TCmap,format_ttf_Table.TKern,format_ttf_Table.TName,format_ttf_Table.THead,format_ttf_Table.THhea,format_ttf_Table.TLoca,format_ttf_Table.TMaxp,format_ttf_Table.TPost,format_ttf_Table.TOS2,format_ttf_Table.TUnkn];
var format_ttf_GlyfDescription = $hxEnums["format.ttf.GlyfDescription"] = { __ename__:true,__constructs__:null
	,TGlyphSimple: ($_=function(header,data) { return {_hx_index:0,header:header,data:data,__enum__:"format.ttf.GlyfDescription",toString:$estr}; },$_._hx_name="TGlyphSimple",$_.__params__ = ["header","data"],$_)
	,TGlyphComposite: ($_=function(header,components) { return {_hx_index:1,header:header,components:components,__enum__:"format.ttf.GlyfDescription",toString:$estr}; },$_._hx_name="TGlyphComposite",$_.__params__ = ["header","components"],$_)
	,TGlyphNull: {_hx_name:"TGlyphNull",_hx_index:2,__enum__:"format.ttf.GlyfDescription",toString:$estr}
};
format_ttf_GlyfDescription.__constructs__ = [format_ttf_GlyfDescription.TGlyphSimple,format_ttf_GlyfDescription.TGlyphComposite,format_ttf_GlyfDescription.TGlyphNull];
var format_ttf_CmapSubTable = $hxEnums["format.ttf.CmapSubTable"] = { __ename__:true,__constructs__:null
	,Cmap0: ($_=function(header,glyphIndexArray) { return {_hx_index:0,header:header,glyphIndexArray:glyphIndexArray,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap0",$_.__params__ = ["header","glyphIndexArray"],$_)
	,Cmap2: ($_=function(header,glyphIndexArray,subHeaderKeys,subHeaders) { return {_hx_index:1,header:header,glyphIndexArray:glyphIndexArray,subHeaderKeys:subHeaderKeys,subHeaders:subHeaders,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap2",$_.__params__ = ["header","glyphIndexArray","subHeaderKeys","subHeaders"],$_)
	,Cmap4: ($_=function(header,glyphIndexArray) { return {_hx_index:2,header:header,glyphIndexArray:glyphIndexArray,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap4",$_.__params__ = ["header","glyphIndexArray"],$_)
	,Cmap6: ($_=function(header,glyphIndexArray,firstCode) { return {_hx_index:3,header:header,glyphIndexArray:glyphIndexArray,firstCode:firstCode,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap6",$_.__params__ = ["header","glyphIndexArray","firstCode"],$_)
	,Cmap8: ($_=function(header,groups,is32) { return {_hx_index:4,header:header,groups:groups,is32:is32,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap8",$_.__params__ = ["header","groups","is32"],$_)
	,Cmap10: ($_=function(header,glyphIndexArray,startCharCode,numChars) { return {_hx_index:5,header:header,glyphIndexArray:glyphIndexArray,startCharCode:startCharCode,numChars:numChars,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap10",$_.__params__ = ["header","glyphIndexArray","startCharCode","numChars"],$_)
	,Cmap12: ($_=function(header,groups) { return {_hx_index:6,header:header,groups:groups,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="Cmap12",$_.__params__ = ["header","groups"],$_)
	,CmapUnk: ($_=function(header,bytes) { return {_hx_index:7,header:header,bytes:bytes,__enum__:"format.ttf.CmapSubTable",toString:$estr}; },$_._hx_name="CmapUnk",$_.__params__ = ["header","bytes"],$_)
};
format_ttf_CmapSubTable.__constructs__ = [format_ttf_CmapSubTable.Cmap0,format_ttf_CmapSubTable.Cmap2,format_ttf_CmapSubTable.Cmap4,format_ttf_CmapSubTable.Cmap6,format_ttf_CmapSubTable.Cmap8,format_ttf_CmapSubTable.Cmap10,format_ttf_CmapSubTable.Cmap12,format_ttf_CmapSubTable.CmapUnk];
var format_ttf_KernSubTable = $hxEnums["format.ttf.KernSubTable"] = { __ename__:true,__constructs__:null
	,KernSub0: ($_=function(kerningPairs) { return {_hx_index:0,kerningPairs:kerningPairs,__enum__:"format.ttf.KernSubTable",toString:$estr}; },$_._hx_name="KernSub0",$_.__params__ = ["kerningPairs"],$_)
	,KernSub1: ($_=function(array) { return {_hx_index:1,array:array,__enum__:"format.ttf.KernSubTable",toString:$estr}; },$_._hx_name="KernSub1",$_.__params__ = ["array"],$_)
};
format_ttf_KernSubTable.__constructs__ = [format_ttf_KernSubTable.KernSub0,format_ttf_KernSubTable.KernSub1];
var format_ttf_Reader = function(i) {
	this.input = i;
	this.input.set_bigEndian(true);
};
format_ttf_Reader.__name__ = true;
format_ttf_Reader.prototype = {
	read: function() {
		var input = this.input;
		var this1 = { majorVersion : input.readUInt16(), minorVersion : input.readUInt16(), numTables : input.readUInt16(), searchRange : input.readUInt16(), entrySelector : input.readUInt16(), rangeShift : input.readUInt16()};
		var header = this1;
		var directory = this.readDirectory(header);
		var bytes = this.tablesHash.h["hhea"];
		if(bytes == null) {
			throw haxe_Exception.thrown("no hhea table found");
		}
		var i = new haxe_io_BytesInput(bytes);
		i.set_bigEndian(true);
		var this1 = { version : i.readInt32(), ascender : i.readInt16(), descender : i.readInt16(), lineGap : i.readInt16(), advanceWidthMax : i.readUInt16(), minLeftSideBearing : i.readInt16(), minRightSideBearing : i.readInt16(), xMaxExtent : i.readInt16(), caretSlopeRise : i.readInt16(), caretSlopeRun : i.readInt16(), caretOffset : i.readInt16(), reserved : i.read(8), metricDataFormat : i.readInt16(), numberOfHMetrics : i.readUInt16()};
		var hheaData = this1;
		var bytes = this.tablesHash.h["head"];
		if(bytes == null) {
			throw haxe_Exception.thrown("no head table found");
		}
		var i = new haxe_io_BytesInput(bytes);
		i.set_bigEndian(true);
		var this1 = { version : i.readInt32(), fontRevision : i.readInt32(), checkSumAdjustment : i.readInt32(), magicNumber : i.readInt32(), flags : i.readUInt16(), unitsPerEm : i.readUInt16(), created : i.readDouble(), modified : i.readDouble(), xMin : i.readInt16(), yMin : i.readInt16(), xMax : i.readInt16(), yMax : i.readInt16(), macStyle : i.readUInt16(), lowestRecPPEM : i.readUInt16(), fontDirectionHint : i.readInt16(), indexToLocFormat : i.readInt16(), glyphDataFormat : i.readInt16()};
		var headData = this1;
		var bytes = this.tablesHash.h["maxp"];
		if(bytes == null) {
			throw haxe_Exception.thrown("no maxp table found");
		}
		var i = new haxe_io_BytesInput(bytes);
		i.set_bigEndian(true);
		var this1 = { versionNumber : i.readInt32(), numGlyphs : i.readUInt16(), maxPoints : i.readUInt16(), maxContours : i.readUInt16(), maxComponentPoints : i.readUInt16(), maxComponentContours : i.readUInt16(), maxZones : i.readUInt16(), maxTwilightPoints : i.readUInt16(), maxStorage : i.readUInt16(), maxFunctionDefs : i.readUInt16(), maxInstructionDefs : i.readUInt16(), maxStackElements : i.readUInt16(), maxSizeOfInstructions : i.readUInt16(), maxComponentElements : i.readUInt16(), maxComponentDepth : i.readUInt16()};
		var maxpData = this1;
		var locaData = this.readLocaTable(this.tablesHash.h["loca"],headData,maxpData);
		var hmtxData = this.readHmtxTable(this.tablesHash.h["hmtx"],maxpData,hheaData);
		var cmapData = this.readCmapTable(this.tablesHash.h["cmap"]);
		var glyfData = this.readGlyfTable(this.tablesHash.h["glyf"],maxpData,locaData,cmapData,hmtxData);
		var kernData = this.readKernTable(this.tablesHash.h["kern"]);
		var bytes = this.tablesHash.h["OS_2"];
		if(bytes == null) {
			throw haxe_Exception.thrown("no maxp table found");
		}
		var i = new haxe_io_BytesInput(bytes);
		i.set_bigEndian(true);
		var this1 = { version : i.readUInt16(), xAvgCharWidth : i.readInt16(), usWeightClass : i.readUInt16(), usWidthClass : i.readUInt16(), fsType : i.readInt16(), ySubscriptXSize : i.readInt16(), ySubscriptYSize : i.readInt16(), ySubscriptXOffset : i.readInt16(), ySubscriptYOffset : i.readInt16(), ySuperscriptXSize : i.readInt16(), ySuperscriptYSize : i.readInt16(), ySuperscriptXOffset : i.readInt16(), ySuperscriptYOffset : i.readInt16(), yStrikeoutSize : i.readInt16(), yStrikeoutPosition : i.readInt16(), sFamilyClass : i.readInt16(), bFamilyType : i.readByte(), bSerifStyle : i.readByte(), bWeight : i.readByte(), bProportion : i.readByte(), bContrast : i.readByte(), bStrokeVariation : i.readByte(), bArmStyle : i.readByte(), bLetterform : i.readByte(), bMidline : i.readByte(), bXHeight : i.readByte(), ulUnicodeRange1 : i.readInt32(), ulUnicodeRange2 : i.readInt32(), ulUnicodeRange3 : i.readInt32(), ulUnicodeRange4 : i.readInt32(), achVendorID : i.readInt32(), fsSelection : i.readInt16(), usFirstCharIndex : i.readUInt16(), usLastCharIndex : i.readUInt16(), sTypoAscender : i.readInt16(), sTypoDescender : i.readInt16(), sTypoLineGap : i.readInt16(), usWinAscent : i.readUInt16(), usWinDescent : i.readUInt16()};
		var os2Data = this1;
		var nameData = this.readNameTable(this.tablesHash.h["_name"]);
		var tables = [format_ttf_Table.THhea(hheaData),format_ttf_Table.THead(headData),format_ttf_Table.TMaxp(maxpData),format_ttf_Table.TLoca(locaData),format_ttf_Table.THmtx(hmtxData),format_ttf_Table.TCmap(cmapData),format_ttf_Table.TGlyf(glyfData),format_ttf_Table.TKern(kernData),format_ttf_Table.TOS2(os2Data),format_ttf_Table.TName(nameData)];
		return { header : header, directory : directory, tables : tables};
	}
	,readDirectory: function(header) {
		this.tablesHash = new haxe_ds_StringMap();
		var directory = [];
		var _g = 0;
		var _g1 = header.numTables;
		while(_g < _g1) {
			var i = _g++;
			var tableId = this.input.readInt32();
			var bytesOutput = new haxe_io_BytesOutput();
			bytesOutput.set_bigEndian(true);
			bytesOutput.writeInt32(tableId);
			var bytesName = bytesOutput.getBytes();
			var tableName = new haxe_io_BytesInput(bytesName).readString(4);
			if(tableName == "name") {
				tableName = "_name";
			}
			directory[i] = { tableId : tableId, tableName : tableName, checksum : this.input.readInt32(), offset : this.input.readInt32(), length : this.input.readInt32()};
		}
		directory.sort($bind(this,this.sortOnOffset32));
		var _g = 0;
		var _g1 = directory.length;
		while(_g < _g1) {
			var i = _g++;
			var entry = directory[i];
			var start = entry.offset;
			var end;
			if(i == directory.length - 1) {
				end = start + entry.length | 0;
			} else {
				end = directory[i + 1].offset;
			}
			var bytes = this.input.read(end - start | 0);
			var _this = this.tablesHash;
			var key = entry.tableName.split("/").join("_");
			_this.h[key] = bytes;
		}
		return directory;
	}
	,sortOnOffset32: function(e1,e2) {
		var x = e1.offset;
		var y = e2.offset;
		var result = 0;
		if(x < y) {
			result = -1;
		}
		if(x == y) {
			result = 0;
		}
		if(x > y) {
			result = 1;
		}
		return result;
	}
	,sortOnOffset16: function(e1,e2) {
		var x = e1.offset;
		var y = e2.offset;
		var result = 0;
		if(x < y) {
			result = -1;
		}
		if(x == y) {
			result = 0;
		}
		if(x > y) {
			result = 1;
		}
		return result;
	}
	,readLocaTable: function(bytes,head,maxp) {
		if(bytes == null) {
			throw haxe_Exception.thrown("no loca table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var offsets = [];
		if(head.indexToLocFormat == 0) {
			var _g = 0;
			var _g1 = maxp.numGlyphs + 1;
			while(_g < _g1) {
				var i = _g++;
				offsets[i] = input.readUInt16() * 2;
			}
		} else {
			var _g = 0;
			var _g1 = maxp.numGlyphs + 1;
			while(_g < _g1) {
				var i = _g++;
				offsets[i] = input.readInt32();
			}
		}
		return { factor : head.indexToLocFormat == 0 ? 2 : 1, offsets : offsets};
	}
	,readHmtxTable: function(bytes,maxp,hhea) {
		if(bytes == null) {
			throw haxe_Exception.thrown("no hmtx table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var metrics = [];
		var _g = 0;
		var _g1 = hhea.numberOfHMetrics;
		while(_g < _g1) {
			var i = _g++;
			metrics.push({ advanceWidth : input.readUInt16(), leftSideBearing : input.readInt16()});
		}
		var len = maxp.numGlyphs - hhea.numberOfHMetrics;
		var lastAdvanceWidth = metrics[metrics.length - 1].advanceWidth;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			metrics.push({ advanceWidth : lastAdvanceWidth, leftSideBearing : input.readInt16()});
		}
		return metrics;
	}
	,readGlyfTable: function(bytes,maxp,loca,cmap,hmtx) {
		if(bytes == null) {
			throw haxe_Exception.thrown("no glyf table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var descriptions = [];
		var _g = 0;
		var _g1 = maxp.numGlyphs;
		while(_g < _g1) {
			var i = _g++;
			descriptions.push(this.readGlyf(i,input,loca.offsets[i + 1] - loca.offsets[i]));
		}
		return descriptions;
	}
	,readGlyf: function(glyphIndex,input,len) {
		if(len > 0) {
			var numberOfContours = input.readInt16();
			var glyphHeader = { numberOfContours : numberOfContours, xMin : input.readInt16(), yMin : input.readInt16(), xMax : input.readInt16(), yMax : input.readInt16()};
			len -= 10;
			if(numberOfContours >= 0) {
				return format_ttf_GlyfDescription.TGlyphSimple(glyphHeader,this.readGlyfSimple(numberOfContours,input,len));
			} else if(numberOfContours == -1) {
				return format_ttf_GlyfDescription.TGlyphComposite(glyphHeader,this.readGlyfComposite(input,len,glyphIndex));
			} else {
				throw haxe_Exception.thrown("unknown GlyfDescription");
			}
		} else {
			return format_ttf_GlyfDescription.TGlyphNull;
		}
	}
	,readGlyfSimple: function(numberOfContours,input,len) {
		var endPtsOfContours = [];
		var _g = 0;
		var _g1 = numberOfContours;
		while(_g < _g1) {
			var i = _g++;
			endPtsOfContours[i] = input.readUInt16();
			len -= 2;
		}
		var count = endPtsOfContours[numberOfContours - 1] + 1;
		var instructionLength = input.readUInt16();
		len -= 2;
		var instructions = [];
		var _g = 0;
		var _g1 = instructionLength;
		while(_g < _g1) {
			var i = _g++;
			instructions[i] = input.readByte();
			--len;
		}
		var flags = [];
		var iindex = 0;
		var jindex = 1;
		while(true) if(iindex < count) {
			flags[iindex] = input.readByte();
			--len;
			if((flags[iindex] & 8) != 0) {
				var repeats = input.readByte();
				--len;
				jindex = 1;
				while(true) if(jindex < repeats + 1) {
					flags[iindex + jindex] = flags[iindex];
					++jindex;
				} else {
					break;
				}
				iindex += repeats;
			}
			++iindex;
		} else {
			break;
		}
		var xCoordinates = [];
		var yCoordinates = [];
		var x = 0;
		var y = 0;
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			if((flags[i] & 16) != 0) {
				if((flags[i] & 2) != 0) {
					x += input.readByte();
					--len;
				}
			} else if((flags[i] & 2) != 0) {
				x += -input.readByte();
				--len;
			} else {
				x += input.readInt16();
				len -= 2;
			}
			xCoordinates[i] = x;
		}
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			if((flags[i] & 32) != 0) {
				if((flags[i] & 4) != 0) {
					y += input.readByte();
					--len;
				}
			} else if((flags[i] & 4) != 0) {
				y += -input.readByte();
				--len;
			} else {
				y += input.readInt16();
				len -= 2;
			}
			yCoordinates[i] = y;
		}
		var glyphSimple = { endPtsOfContours : endPtsOfContours, flags : flags, instructions : instructions, xCoordinates : xCoordinates, yCoordinates : yCoordinates};
		input.read(len);
		return glyphSimple;
	}
	,readGlyfComposite: function(input,len,glyphIndex) {
		var components = [];
		input.read(len);
		return components;
	}
	,readCmapTable: function(bytes) {
		if(bytes == null) {
			throw haxe_Exception.thrown("no cmap table found");
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var version = input.readUInt16();
		var numberSubtables = input.readUInt16();
		var directory = [];
		var _g = 0;
		var _g1 = numberSubtables;
		while(_g < _g1) {
			var i = _g++;
			directory.push({ platformId : input.readUInt16(), platformSpecificId : input.readUInt16(), offset : input.readInt32()});
		}
		var subTables = [];
		var _g = 0;
		var _g1 = numberSubtables;
		while(_g < _g1) {
			var i = _g++;
			subTables.push(this.readSubTable(bytes,directory[i]));
		}
		return subTables;
	}
	,readSubTable: function(bytes,entry) {
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		input.read(entry.offset);
		var cmapFormat = input.readUInt16();
		var length = input.readUInt16();
		var language = input.readUInt16();
		var cmapHeader = { platformId : entry.platformId, platformSpecificId : entry.platformSpecificId, offset : entry.offset, format : cmapFormat, language : language};
		this.glyphIndexArray = [];
		this.allGlyphs = [];
		if(cmapFormat == 0) {
			var _g = 0;
			while(_g < 256) {
				var j = _g++;
				this.glyphIndexArray[j] = { charCode : j, index : input.readByte(), char : format_ttf_MacGlyphNames.names[j]};
			}
			return format_ttf_CmapSubTable.Cmap0(cmapHeader,this.glyphIndexArray);
		} else if(cmapFormat == 4) {
			var segCount = input.readUInt16() / 2;
			var searchRange = input.readUInt16();
			var entrySelector = input.readUInt16();
			var rangeShift = input.readUInt16();
			var endCodes = [];
			var startCodes = [];
			var idDeltas = [];
			var idRangeOffsets = [];
			var glyphIndices = [];
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				endCodes.push(input.readUInt16());
			}
			input.readUInt16();
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				startCodes.push(input.readUInt16());
			}
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				idDeltas.push(input.readUInt16());
			}
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				idRangeOffsets.push(input.readUInt16());
			}
			var count = (length - (8 * segCount + 16)) / 2 | 0;
			var _g = 0;
			var _g1 = count;
			while(_g < _g1) {
				var i = _g++;
				glyphIndices[i] = input.readUInt16();
			}
			this.glyphIndexArray[0] = { charCode : 0, index : 0, char : String.fromCodePoint(0)};
			this.glyphIndexArray[1] = { charCode : 1, index : 1, char : "\x01"};
			this.glyphIndexArray[2] = { charCode : 2, index : 2, char : "\x02"};
			this.allGlyphs.concat(this.glyphIndexArray);
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				var _g2 = startCodes[i];
				var _g3 = endCodes[i] + 1;
				while(_g2 < _g3) {
					var j = _g2++;
					var index = this.mapCharCode(j,glyphIndices,segCount,startCodes,endCodes,idRangeOffsets,idDeltas);
					var glyphIndex = { charCode : j, index : index, char : String.fromCodePoint(j)};
					this.glyphIndexArray[j] = glyphIndex;
					this.allGlyphs.push(glyphIndex);
				}
			}
			return format_ttf_CmapSubTable.Cmap4(cmapHeader,this.glyphIndexArray);
		} else if(cmapFormat == 6) {
			var firstCode = input.readUInt16();
			var entryCount = input.readUInt16();
			var _g = 0;
			var _g1 = entryCount;
			while(_g < _g1) {
				var j = _g++;
				var glyphIndex = { charCode : j, index : input.readUInt16(), char : format_ttf_MacGlyphNames.names[j]};
				this.glyphIndexArray[j] = glyphIndex;
			}
			return format_ttf_CmapSubTable.Cmap6(cmapHeader,this.glyphIndexArray,firstCode);
		} else {
			return format_ttf_CmapSubTable.CmapUnk(cmapHeader,bytes);
		}
	}
	,mapCharCode: function(charCode,glyphIndices,segCount,startCodes,endCodes,idRangeOffsets,idDeltas) {
		try {
			var _g = 0;
			var _g1 = segCount;
			while(_g < _g1) {
				var i = _g++;
				if(endCodes[i] >= charCode) {
					if(startCodes[i] <= charCode) {
						if(idRangeOffsets[i] > 0) {
							var index = idRangeOffsets[i] / 2 + (charCode - startCodes[i]) - (segCount - i) | 0;
							return glyphIndices[index];
						} else {
							var index1 = (idDeltas[i] + charCode) % 65536 | 0;
							return index1;
						}
					} else {
						break;
					}
				}
			}
			return 0;
		} catch( _g ) {
			return 0;
		}
	}
	,getCharCodeFromIndex: function(index) {
		var _g = 0;
		var _g1 = this.glyphIndexArray.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.glyphIndexArray[i] != null && this.glyphIndexArray[i].index == index) {
				return this.glyphIndexArray[i].charCode;
			}
		}
		throw haxe_Exception.thrown("charcode not found for index " + index);
	}
	,readKernTable: function(bytes) {
		if(bytes == null) {
			return [];
		}
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var version = input.readUInt16();
		var nTables = input.readUInt16();
		var tables = [];
		var _g = 0;
		var _g1 = nTables;
		while(_g < _g1) {
			var i = _g++;
			var version = input.readUInt16();
			var length = input.readUInt16();
			var coverage = input.readUInt16();
			var _format = coverage >> 8;
			switch(_format) {
			case 0:
				var nPairs = input.readUInt16();
				var searchRange = input.readUInt16();
				var entrySelector = input.readUInt16();
				var rangeShift = input.readUInt16();
				this.kerningPairs = [];
				var _g2 = 0;
				var _g3 = nPairs;
				while(_g2 < _g3) {
					var i1 = _g2++;
					this.kerningPairs.push({ left : this.getCharCodeFromIndex(input.readUInt16()), right : this.getCharCodeFromIndex(input.readUInt16()), value : input.readInt16()});
				}
				tables.push(format_ttf_KernSubTable.KernSub0(this.kerningPairs));
				break;
			case 2:
				var rowWidth = input.readUInt16();
				var leftOffsetTable = input.readUInt16();
				var rightOffsetTable = input.readUInt16();
				var array = input.readUInt16();
				var firstGlyph = input.readUInt16();
				var nGlyphs = input.readUInt16();
				var offsets = [];
				var _g4 = 0;
				var _g5 = nGlyphs;
				while(_g4 < _g5) {
					var i2 = _g4++;
					offsets.push(input.readUInt16());
				}
				tables.push(format_ttf_KernSubTable.KernSub1(offsets));
				break;
			}
		}
		return tables;
	}
	,readNameTable: function(bytes) {
		var input = new haxe_io_BytesInput(bytes);
		input.set_bigEndian(true);
		var _format = input.readUInt16();
		var count = input.readUInt16();
		var stringOffset = input.readUInt16();
		var nameRecords = [];
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			nameRecords.push({ platformId : input.readUInt16(), platformSpecificId : input.readUInt16(), languageID : input.readUInt16(), nameID : input.readUInt16(), length : input.readUInt16(), offset : input.readUInt16(), record : ""});
		}
		nameRecords.sort($bind(this,this.sortOnOffset16));
		var fontNameRecord = null;
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			if(nameRecords[i].nameID == 4 && (nameRecords[i].platformId == 3 || nameRecords[i].platformId == 0)) {
				fontNameRecord = nameRecords[i];
				break;
			}
		}
		if(fontNameRecord == null) {
			throw haxe_Exception.thrown("fontNameRecord not found");
		} else {
			input.read(fontNameRecord.offset);
			var _g = 0;
			var _g1 = fontNameRecord.length / 2 | 0;
			while(_g < _g1) {
				var i = _g++;
				var fontNameRecord1 = fontNameRecord;
				var fontNameRecord2 = fontNameRecord1.record;
				var code = input.readUInt16();
				fontNameRecord1.record = fontNameRecord2 + String.fromCodePoint(code);
			}
		}
		this.fontName = fontNameRecord.record;
		return nameRecords;
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL_OLD: {_hx_name:"SMALL_OLD",_hx_index:4,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE,fracs_DifferencePreference.SMALL_OLD];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_Resource = function() { };
haxe_Resource.__name__ = true;
haxe_Resource.getBytes = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return haxe_io_Bytes.ofString(x.str);
			}
			return haxe_crypto_Base64.decode(x.data);
		}
	}
	return null;
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
};
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:true,__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
haxe_exceptions_PosException.__name__ = true;
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
haxe_exceptions_NotImplementedException.__name__ = true;
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
});
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var htmlHelper_tools_AnimateTimer = function() { };
htmlHelper_tools_AnimateTimer.__name__ = true;
htmlHelper_tools_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(htmlHelper_tools_AnimateTimer.loop);
	if(htmlHelper_tools_AnimateTimer.onFrame != null) {
		htmlHelper_tools_AnimateTimer.onFrame(htmlHelper_tools_AnimateTimer.counter);
	}
	htmlHelper_tools_AnimateTimer.counter++;
	return true;
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var truetype_TTFGlyphUtils = function(ttf) {
	var _g = 0;
	var _g1 = ttf.tables;
	while(_g < _g1.length) {
		var table = _g1[_g];
		++_g;
		switch(table._hx_index) {
		case 0:
			var descriptions = table.descriptions;
			haxe_Log.trace("TGlyf descriptions: " + descriptions.length,{ fileName : "truetype/TTFGlyphUtils.hx", lineNumber : 24, className : "truetype.TTFGlyphUtils", methodName : "new"});
			this.descriptions = descriptions;
			this.length = this.descriptions.length;
			break;
		case 5:
			var headdata = table.data;
			this.headdata = headdata;
			break;
		default:
		}
	}
};
truetype_TTFGlyphUtils.__name__ = true;
truetype_TTFGlyphUtils.prototype = {
	getGlyphSimple: function(index) {
		var description = this.descriptions[index];
		switch(description._hx_index) {
		case 0:
			var h = description.header;
			var data = description.data;
			return data;
		case 1:
			var h = description.header;
			var components = description.components;
			throw haxe_Exception.thrown("TGlyphComposite " + index);
		case 2:
			haxe_Log.trace("TGlyphNull " + index,{ fileName : "truetype/TTFGlyphUtils.hx", lineNumber : 44, className : "truetype.TTFGlyphUtils", methodName : "getGlyphSimple"});
			return null;
		}
	}
	,getGlyphHeader: function(index) {
		var description = this.descriptions[index];
		switch(description._hx_index) {
		case 0:
			var header = description.header;
			var data = description.data;
			return header;
		case 1:
			var header = description.header;
			var components = description.components;
			return header;
		case 2:
			haxe_Log.trace("TGlyphNull " + index,{ fileName : "truetype/TTFGlyphUtils.hx", lineNumber : 57, className : "truetype.TTFGlyphUtils", methodName : "getGlyphHeader"});
			return null;
		}
	}
	,getGlyphContours: function(index) {
		var simple = this.getGlyphSimple(index);
		var points = [];
		var _g = 0;
		var _g1 = simple.flags.length;
		while(_g < _g1) {
			var i = _g++;
			var onCurve = simple.flags[i] % 2 != 0;
			var point = { onCurve : onCurve, x : simple.xCoordinates[i], y : simple.yCoordinates[i]};
			points.push(point);
		}
		var p = 0;
		var c = 0;
		var first = 1;
		var contour = [];
		var contours = [];
		while(p < points.length) {
			var point = points[p];
			if(first == 1) {
				first = 0;
			}
			contour.push(point);
			if(p == simple.endPtsOfContours[c]) {
				++c;
				first = 1;
				contours.push(contour.slice());
				contour = [];
			}
			++p;
		}
		this.adjustContours(contours);
		return contours;
	}
	,adjustContours: function(contours) {
		var hasOnCurve = function(contour) {
			var _g = [];
			var _g1 = 0;
			var _g2 = contour;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v.onCurve == true) {
					_g.push(v);
				}
			}
			return _g.length > 0;
		};
		var shiftPoints = function(contour) {
			var first = contour[0];
			while(first.onCurve == false) {
				contour.push(contour.shift());
				first = contour[0];
			}
		};
		var addControlPointOnCurve = function(contour) {
			var p0 = contour[0];
			var p1 = contour[contour.length - 1];
			var newX = (p1.x - p0.x) / 2 + p0.x;
			var newY = (p1.y - p0.y) / 2 + p0.y;
			var newPoint = { x : newX, y : newY, onCurve : true};
			contour.unshift(newPoint);
		};
		var _g = 0;
		while(_g < contours.length) {
			var contour = contours[_g];
			++_g;
			if(hasOnCurve(contour)) {
				shiftPoints(contour);
			} else {
				addControlPointOnCurve(contour);
			}
		}
		var _g = 0;
		while(_g < contours.length) {
			var contour = contours[_g];
			++_g;
			var newContour = [];
			var _g1 = 0;
			var _g2 = contour.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var point = contour[i];
				newContour.push(point);
				if(i > 0) {
					var prevPoint = contour[i - 1];
					if(point.onCurve == false && prevPoint.onCurve == false) {
						var newX = (point.x - prevPoint.x) / 2 + prevPoint.x;
						var newY = (point.y - prevPoint.y) / 2 + prevPoint.y;
						var newPoint = { x : newX, y : newY, onCurve : true};
						newContour.splice(newContour.length - 1,0,newPoint);
					}
				}
			}
			newContour.push(newContour[0]);
			contours[contours.indexOf(contour)] = newContour;
		}
	}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
haxe_Resource.content = [{ name : "font", data : "AAEAAAAPAIAAAwBwRkZUTWucvysAAVnAAAAAHEdERUYLLw2oAAEtxAAAAFpHUE9T28cHIwABP6QAABoaR1NVQrUi0iMAAS4gAAARhE9TLzKKZk5KAAABeAAAAGBjbWFwuHinsQAADUQAAAPmZ2FzcP//AAMAAS28AAAACGdseWaQJTvmAAAW5AAA2nBoZWFk+pBpsgAAAPwAAAA2aGhlYQfGBgYAAAE0AAAAJGhtdHiCSWMtAAAB2AAAC2xsb2NhYxSamgAAESwAAAW4bWF4cAMkAEkAAAFYAAAAIG5hbWXC36eqAADxVAAAJHJwb3N0Zjc/NgABFcgAABfzAAEAAAABAABEqeLYXw889QALA+gAAAAAy7wTAgAAAADLvBMC/z7/BgS6A8MAAQAIAAIAAAAAAAAAAQAAA8v/AgAABN3/Pv9LBLoAAQAAAAAAAAAAAAAAAAAAAtsAAQAAAtsARgAHAAAAAAACAAAAAQABAAAAQAAAAAAAAAADAlwC7gAFAAACvAKKAAAAjAK8AooAAAHdADIA+gAAAgsIAwICAgICBIAAAg9QACBKAAAAAAAAAABMSU5PACAADfsEAvT/DADIA8sA/iAAAJcAAAAAAfICxAAAACAABAIAAAAB9AAAAU0AAAH0AAAA+gAAAWUAUQHyAFYCWwAuAoYAIwOPAB0DDQAtAS8AVgFWAB0BVgA2AekAHAKaADgBLAAUAUYAJAEsADEBn//5AoYALgKGAEAChgA1AoYAIAKGABkChgAoAoYAKwKGAD8ChgA5AoYALAFMAEQBTAAeApoATwKaAEQCmgBPAiIAKAMgAB0C2f/yApkASQK4ACgDBgBJAl8ASQJAAEkDAQAoAvwASQE+AEkCEf/9AscASQIOAEkDuwBJAxYASQNTACgCgABJA1kAJAKXAEkCTwAPAkUABQLiAEICqv/xBAEAAAK///gCnf/sAnsAJwFWADUBnwABAVYASQKyAEkB9AAAASz/2QI2ACECkwBCAfcAJwKSACcCVAAnAWwAAAKSACcCaQBCASgANgEr/9sCUwBBASoAQgOcAEACaABAAngAJwKRAEACkQAnAYwAQAHYAAsBdAACAmYAOwI3//8DZwAAAlL//QI3//8CAAAiAVYABgDxADcBVgAyApoAVQD6AAABZQBRAoYAUQKGAEgDtgCSAoYADADxADcCXwAoASz/1gMgABQBgAAtAh8AGQKaADMBRgAkAlgASAEs/+4BoAAoApoAPQGkAC0BpAAnASwARQKXAEACagAYASwAMQEsABEBpAAvAYAAJQIfACIDrAAuA6wALgOsACcCIgATAtn/8gLZ//IC2f/yAtn/8gLZ//IC2f/yBAn//AK4ACgCXwBJAl8ASQJfAEkCXwBJAT7/5wE+AEkBPv/ZAT7/3wMGAA0DFgBJA1MAKANTACgDUwAoA1MAKANTACgCmgA/A1MAJwLiAEIC4gBCAuIAQgLiAEICnf/sAoAASQKbAEACNgAhAjYAIQI2ACECNgAhAjYAIQI2ACEDgwAhAfcAJwJUACcCVAAnAlQAJwJUACcBKP/WASgAQgEo/9IBKP/WAngAJwJoAEACeAAnAngAJwJ4ACcCeAAnAngAJwKaAE8CeAAYAmYAOwJmADsCZgA7AmYAOwI3//8CkwBCAjf//wLZ//ICNgAhAtn/8gI2ACEC2f/yAjYAIQK4ACgB9wAnArgAKAH3ACcCuAAoAfcAJwK4ACgB9wAnAwYASQMXACcDBgANApIAJwJfAEkCVAAnAl8ASQJUACcCXwBJAlQAJwJfAEkCVAAnAl8ASQJUACcDAQAoApIAJwMBACgCkgAnAwEAKAKSACcDAQAoApIAJwL8AEkCaQBCAvwASQJpABQBPv/mASj/3AE+//YBKP/uAT7/8QEo/+YBPgAoASgAFQE+AEYBKABCA0UASQJNADYCEf/9ASv/0ALHAEkCUwBBAlMAQQIOAEkBKgBCAg4ASQEqAAsCDgBJAbAAQgIOAEkBwABCAg4ACQEqAAgDFgBJAmgAQAMWAEkCaABAAxYASQJoAEACwv/3AxYASQJoAEADUwAoAngAJwNTACgCeAAnA1MAKAJ4ACcD+wAoA80AJwKXAEkBjABAApcASQGMAAwClwBJAYwAHwJPAA8B2AALAk8ADwHYAAsCTwAPAdgACwJPAA8B2AALAkUABQF0AAICRQAFAbAAAgJFAAUBdAACAuIAQgJmADsC4gBCAmYAOwLiAEICZgA7AuIAQgJmADsC4gBCAmYAOwLiAEICZgA7BAEAAANnAAACnf/sAjf//wKd/+wCewAnAgAAIgJ7ACcCAAAiAnsAJwIAACIChv/+Ak8ADwHYAAsCRQAFAXQAAgEr/9sBLP/RASz/0QEs/+4BLP/o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BoAGoAbKBvAHOAdKB2gHfgegB7oH0gfqB/wIDAgeCDAIPghMCH4IrAjSCQAJLAlMCYIJogm+CegKAgoOCj4KXgqACrAK3gr8CywLTgtuC4QLpgu+C+IL9gwiDDAMXAyADIAMnAzODPYNNA1YDWwNyA3sDjAOXA52DoYOkg7SDuAPAA8cD0QPeg+ID7QPzA/gEAQQFhA8EFgQiBDCERYRUBFwEZARtBHmEhwSUhJ2ErgS1hL0ExYTShNcE24ThBOsE9oUDBQ4FGQUlBTQFRIVLBVyFZYVuhXiFhwWOhZcFpgW0BcKF0gXlBfkGDIYghjCGPQZJhlcGaQZthnIGd4aBhpCGnoaohrKGvYbMBtuG5Yb0Bv2HBwcRhyCHKwc2h0aHToddB2gHegeFh5eHoweuB7oHxgfTB9+H7Af4CAUIEggdiCqIMgg+iEkIWYhjCHGIfIiMCJSIogivCL8IzgjhCO6I/4kLiRsJI4kuCTWJP4lIiVGJVglaiWIJaolyiX4JhImHiZEJoImrCbSJvQnFCcsJ0QnVidsJ4AnmCeqJ8gn4if8KBQoNChaKHoooCjEKO4pFilAKXApnCnEKfwqNCpmKpQqxisMKzgrXCuIK6wr3CwELFIsiCzaLRQtdC2+LhAuSi5kLowuqi7SLuwvFi9ML4QvqC/OL/4wMjBsMKgw0jD+MTAxYjGOMbox3DIKMj4yXDJ4MpwyvjLgMwAzNDOCM7oz1DP8NBg0KjQ8NEo0ZjR6NJ40ujTaNO41BjU2NWI1hDWiNdY2ADYYNkQ2jDaYNsI24jcWN0I3ZDeIN6g34jf6OBQ4MjhkOHQ4ljisONY5DDkkOVA5bDmMOao5wjnmOfg6GDo+OlA6djqoOsI62jr4Ow47KjtMO3A7jju6O+g8DjxAPII8sDzAPOA9DD0uPWA9eD2iPbo92D32Pgo+Kj48Pmw+kj6kPsg++j8SPyo/Rj9cP3g/mD+8P9hAAEAsQE5AgkDMQQBBGEFCQXJBjEG2QeBCEEI2Ql5CfkKeQtJC6EL6QwpDMkNaQ4JDqkPoRCZERERuRHpEiESWRKZEtkTERNpE8EUGRRxFOEVKRXZFzEXeRfBGKEY4RlhGdEagRsxG3kcaR0ZHZkd4R6BH1kfySBxISEhYSJJIvkj8SUZJfEm4SfRKHkpOSnhKsErIStxK+EsGSxZLKktCS4JLyEwC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AAEECQAKCJQJUQADAAEECQALAC4WMgADAAEECQAMAEoWegADAAEECQANB54W7AADAAEECQAOAD4iXAADAAEECQAQAB4ivABDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMAAzACAALQAgADIAMAAxADIAIABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIACwAIAB3AHcAdwAuAGwAaQBuAG8AdAB5AHAAZQAuAGMAbwBtAC4AIABBAGwAbAAgAHIAaQBnAGgAdABzACAAcgBlAHMAZQByAHYAZQBkAC4AIABUAGgAaQBzACAAZgBvAG4AdAAgAHMAbwBmAHQAdwBhAHIAZQAgAG0AYQB5ACAAbgBvAHQAIABiAGUAIAByAGUAcAByAG8AZAB1AGMAZQBkACwAIABtAG8AZABpAGYAaQBlAGQALAAgAGQAaQBzAGMAbABvAHMAZQBkACAAbwByACAAdAByAGEAbgBzAGYAZQByAHIAZQBkACAAdwBpAHQAaABvAHUAdAAgAHQAaABlACAAZQB4AHAAcgBlAHMAcwAgAHcAcgBpAHQAdABlAG4AIABhAHAAcAByAG8AdgBhAGwAIABvAGYAIABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIAC4AIABBAHYAZQBuAGkAcgAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEwAaQBuAG8AdAB5AHAAZQAgAEcAbQBiAEgAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAdABoAGUAIABVAC4AUwAuACAAUABhAHQAZQBuAHQAIABhAG4AZAAgAFQAcgBhAGQAZQBtAGEAcgBrACAATwBmAGYAaQBjAGUAIABhAG4AZAAgAG0AYQB5ACAAYgBlACAAcgBlAGcAaQBzAHQAZQByAGUAZAAgAGkAbgAgAGMAZQByAHQAYQBpAG4AIABvAHQAaABlAHIAIABqAHUAcgBpAHMAZABpAGMAdABpAG8AbgBzAC4AIABUAGgAaQBzACAAdAB5AHAAZQBmAGEAYwBlACAAaQBzACAAbwByAGkAZwBpAG4AYQBsACAAYQByAHQAdwBvAHIAawAgAG8AZgAgAEEAZAByAGkAYQBuACAARgByAHUAdABpAGcAZQByACAAYQBuAGQAIABBAGsAaQByAGEAIABLAG8AYgBhAHkAYQBzAGgAaQAuACAAVABoAGUAIABkAGUAcwBpAGcAbgAgAG0AYQB5ACAAYgBlACAAcAByAG8AdABlAGMAdABlAGQAIABpAG4AIABjAGUAcgB0AGEAaQBuACAAagB1AHIAaQBzAGQAaQBjAHQAaQBvAG4AcwAuAABDb3B5cmlnaHQgqSAyMDAzIC0gMjAxMiBMaW5vdHlwZSBHbWJILCB3d3cubGlub3R5cGUuY29tLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZvbnQgc29mdHdhcmUgbWF5IG5vdCBiZSByZXByb2R1Y2VkLCBtb2RpZmllZCwgZGlzY2xvc2VkIG9yIHRyYW5zZmVycmVkIHdpdGhvdXQgdGhlIGV4cHJlc3Mgd3JpdHRlbiBhcHByb3ZhbCBvZiBMaW5vdHlwZSBHbWJILiBBdmVuaXIgaXMgYSB0cmFkZW1hcmsgb2YgTGlub3R5cGUgR21iSCByZWdpc3RlcmVkIGluIHRoZSBVLlMuIFBhdGVudCBhbmQgVHJhZGVtYXJrIE9mZmljZSBhbmQgbWF5IGJlIHJlZ2lzdGVyZWQgaW4gY2VydGFpbiBvdGhlciBqdXJpc2RpY3Rpb25zLiBUaGlzIHR5cGVmYWNlIGlzIG9yaWdpbmFsIGFydHdvcmsgb2YgQWRyaWFuIEZydXRpZ2VyIGFuZCBBa2lyYSBLb2JheWFzaGkuIFRoZSBkZXNpZ24gbWF5IGJlIHByb3RlY3RlZCBpbiBjZXJ0YWluIGp1cmlzZGljdGlvbnMuAABBAHYAZQBuAGkAcgAgAE4AZQB4AHQAIABDAHkAcgAgAE0AZQBkAGkAdQBtAABBdmVuaXIgTmV4dCBDeXIgTWVkaXVtAABCAG8AbABkAABCb2xkAABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIADoAQQB2AGUAbgBpAHIAIABOAGUAeAB0ACAAQwB5AHIAIABCAG8AbABkADoAMgAwADEAMgAATGlub3R5cGUgR21iSDpBdmVuaXIgTmV4dCBDeXIgQm9sZDoyMDEyAABBAHYAZQBuAGkAcgBOAGUAeAB0AEMAeQByAC0AQgBvAGwAZAAAQXZlbmlyTmV4dEN5ci1Cb2xkAABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAAVmVyc2lvbiAxLjAwAABBAHYAZQBuAGkAcgBOAGUAeAB0AEMAeQByAC0AQgBvAGwAZAAAQXZlbmlyTmV4dEN5ci1Cb2xkAABBAHYAZQBuAGkAcgAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEwAaQBuAG8AdAB5AHAAZQAgAEcAbQBiAEgAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAdABoAGUAIABVAC4AUwAuACAAUABhAHQAZQBuAHQAIABhAG4AZAAgAFQAcgBhAGQAZQBtAGEAcgBrACAATwBmAGYAaQBjAGUAIABhAG4AZAAgAG0AYQB5ACAAYgBlACAAcgBlAGcAaQBzAHQAZQByAGUAZAAgAGkAbgAgAGMAZQByAHQAYQBpAG4AIABvAHQAaABlAHIAIABqAHUAcgBpAHMAZABpAGMAdABpAG8AbgBzAC4AAEF2ZW5pciBpcyBhIHRyYWRlbWFyayBvZiBMaW5vdHlwZSBHbWJIIHJlZ2lzdGVyZWQgaW4gdGhlIFUuUy4gUGF0ZW50IGFuZCBUcmFkZW1hcmsgT2ZmaWNlIGFuZCBtYXkgYmUgcmVnaXN0ZXJlZCBpbiBjZXJ0YWluIG90aGVyIGp1cmlzZGljdGlvbnMuAABMAGkAbgBvAHQAeQBwAGUAIABHAG0AYgBIAABMaW5vdHlwZSBHbWJIAABBAGQAcgBpAGEAbgAgAEYAcgB1AHQAaQBnAGUAcgAgAGEAbgBkACAAQQBrAGkAcgBhACAASwBvAGIAYQB5AGEAcwBoAGkAAEFkcmlhbiBGcnV0aWdlciBhbmQgQWtpcmEgS29iYXlhc2hpAABBAGQAcgBpAGEAbgAgAEYAcgB1AHQAaQBnAGUAcgAgAGQAZQBzAGkAZwBuAGUAZAAgAEEAdgBlAG4AaQByACAAaQBuACAAMQA5ADgAOAAsACAAYQBmAHQAZQByACAAeQBlAGEAcgBzACAAbwBmACAAaABhAHYAaQBuAGcAIABhAG4AIABpAG4AdABlAHIAZQBzAHQAIABpAG4AIABzAGEAbgBzACAAcwBlAHIAaQBmACAAdAB5AHAAZQBmAGEAYwBlAHMALgAgAEkAbgAgAGEAbgAgAGkAbgB0AGUAcgB2AGkAZQB3ACAAdwBpAHQAaAAgAEwAaQBuAG8AdAB5AHAAZQAsACAAaABlACAAcwBhAGkAZAAgAGgAZQAgAGYAZQBsAHQAIABhAG4AIABvAGIAbABpAGcAYQB0AGkAbwBuACAAdABvACAAZABlAHMAaQBnAG4AIABhACAAbABpAG4AZQBhAHIAIABzAGEAbgBzACAAaQBuACAAdABoAGUAIAB0AHIAYQBkAGkAdABpAG8AbgAgAG8AZgAgAEUAcgBiAGEAcgAgAGEAbgBkACAARgB1AHQAdQByAGEALAAgAGIAdQB0ACAAdABvACAAYQBsAHMAbwAgAG0AYQBrAGUAIAB1AHMAZQAgAG8AZgAgAHQAaABlACAAZQB4AHAAZQByAGkAZQBuAGMAZQAgAGEAbgBkACAAcwB0AHkAbABpAHMAdABpAGMAIABkAGUAdgBlAGwAbwBwAG0AZQBuAHQAcwAgAG8AZgAgAHQAaABlACAAdAB3AGUAbgB0AGkAZQB0AGgAIABjAGUAbgB0AHUAcgB5AC4AIABUAGgAZQAgAHcAbwByAGQAIABBAHYAZQBuAGkAcgAgAG0AZQBhAG4AcwAgACcAZgB1AHQAdQByAGUAJwAgAGkAbgAgAEYAcgBlAG4AYwBoACAAYQBuAGQAIABoAGkAbgB0AHMAIAB0AGgAYQB0ACAAdABoAGUAIAB0AHkAcABlAGYAYQBjAGUAIABvAHcAZQBzACAAcwBvAG0AZQAgAG8AZgAgAGkAdABzACAAaQBuAHQAZQByAHAAcgBlAHQAYQB0AGkAbwBuACAAdABvACAARgB1AHQAdQByAGEALgAgAEIAdQB0ACAAdQBuAGwAaQBrAGUAIABGAHUAdAB1AHIAYQAsACAAQQB2AGUAbgBpAHIAIABpAHMAIABuAG8AdAAgAHAAdQByAGUAbAB5ACAAZwBlAG8AbQBlAHQAcgBpAGMAOwAgAGkAdAAgAGgAYQBzACAAdgBlAHIAdABpAGMAYQBsACAAcwB0AHIAbwBrAGUAcwAgAHQAaABhAHQAIABhAHIAZQAgAHQAaABpAGMAawBlAHIAIAB0AGgAYQBuACAAdABoAGUAIABoAG8AcgBpAHoAbwBuAHQAYQBsAHMALAAgAGEAbgAgACIAbwAiACAAdABoAGEAdAAgAGkAcwAgAG4AbwB0ACAAYQAgAHAAZQByAGYAZQBjAHQAIABjAGkAcgBjAGwAZQAsACAAYQBuAGQAIABzAGgAbwByAHQAZQBuAGUAZAAgAGEAcwBjAGUAbgBkAGUAcgBzAC4AIABUAGgAZQBzAGUAIABuAHUAYQBuAGMAZQBzACAAYQBpAGQAIABpAG4AIABsAGUAZwBpAGIAaQBsAGkAdAB5ACAAYQBuAGQAIABnAGkAdgBlACAAQQB2AGUAbgBpAHIAIABhACAAaABhAHIAbQBvAG4AaQBvAHUAcwAgAGEAbgBkACAAcwBlAG4AcwBpAGIAbABlACAAYQBwAHAAZQBhAHIAYQBuAGMAZQAgAGYAbwByACAAYgBvAHQAaAAgAHQAZQB4AHQAcwAgAGEAbgBkACAAaABlAGEAZABsAGkAbgBlAHMALgAgAEkAbgAgADIAMAAwADQAIABBAGQAcgBpAGEAbgAgAEYAcgB1AHQAaQBnAGUAcgAgAGEAbgBkACAAdABoAGUAIAB0AHkAcABlACAAZABpAHIAZQBjAHQAbwByACAAbwBmACAATABpAG4AbwB0AHkAcABlACAARwBtAGIASAAgAEEAawBpAHIAYQAgAEsAbwBiAGEAeQBhAHMAaABpACAAcgBlAHcAbwByAGsAZQBkACAAdABoAGUAIABBAHYAZQBuAGkAcgAgAGEAbgBkACAAYwByAGUAYQB0AGUAZAAgAHQAaABlACAAQQB2AGUAbgBpAHIAIABOAGUAeAB0ACAAZgBvAHIAIAB0AGgAZQAgAFAAbABhAHQAaQBuAHUAbQAgAEMAbwBsAGwAZQBjAHQAaQBvAG4ALgAgAEkAdAAgAGkAbgBjAGwAdQBkAGUAcwAgAG4AZQB3ACAAcwBtAGEAbABsACAAYwBhAHAAcwAsACAAbgBlAHcAbAB5ACAAZABlAHMAaQBnAG4AZQBkACAAdAByAHUAZQAgAGkAdABhAGwAaQBjAHMALAAgAGEAbgBkACAAYQAgAGMAbwBtAHAAbABlAHQAZQAgAG4AZQB3ACAAcgBhAG4AZwBlACAAbwBmACAAYwBvAG4AZABlAG4AcwBlAGQAIAB3AGUAaQBnAGgAdABzAC4AIABBAHYAZQBuAGkAcgAgAE4AZQB4AHQAIABpAHMAIABhACAAdgBlAHIAcwBhAHQAaQBsAGUAIABzAGEAbgBzACAAcwBlAHIAaQBmACAAZgBhAG0AaQBsAHkALAAgAHIAZQBhAGQAeQAgAGYAbwByACAAbABhAHIAZwBlACAAYQBuAGQAIABjAG8AbQBwAGwAZQB4ACAAcAByAG8AagBlAGMAdABzACAAZgByAG8AbQAgAGIAbwBvAGsAcwAgAHQAbwAgAHMAaQBnAG4AYQBnAGUAIAB0AG8AIABhAGQAdgBlAHIAdABpAHMAaQBuAGcALgAAQWRyaWFuIEZydXRpZ2VyIGRlc2lnbmVkIEF2ZW5pciBpbiAxOTg4LCBhZnRlciB5ZWFycyBvZiBoYXZpbmcgYW4gaW50ZXJlc3QgaW4gc2FucyBzZXJpZiB0eXBlZmFjZXMuIEluIGFuIGludGVydmlldyB3aXRoIExpbm90eXBlLCBoZSBzYWlkIGhlIGZlbHQgYW4gb2JsaWdhdGlvbiB0byBkZXNpZ24gYSBsaW5lYXIgc2FucyBpbiB0aGUgdHJhZGl0aW9uIG9mIEVyYmFyIGFuZCBGdXR1cmEsIGJ1dCB0byBhbHNvIG1ha2UgdXNlIG9mIHRoZSBleHBlcmllbmNlIGFuZCBzdHlsaXN0aWMgZGV2ZWxvcG1lbnRzIG9mIHRoZSB0d2VudGlldGggY2VudHVyeS4gVGhlIHdvcmQgQXZlbmlyIG1lYW5zICdmdXR1cmUnIGluIEZyZW5jaCBhbmQgaGludHMgdGhhdCB0aGUgdHlwZWZhY2Ugb3dlcyBzb21lIG9mIGl0cyBpbnRlcnByZXRhdGlvbiB0byBGdXR1cmEuIEJ1dCB1bmxpa2UgRnV0dXJhLCBBdmVuaXIgaXMgbm90IHB1cmVseSBnZW9tZXRyaWM7IGl0IGhhcyB2ZXJ0aWNhbCBzdHJva2VzIHRoYXQgYXJlIHRoaWNrZXIgdGhhbiB0aGUgaG9yaXpvbnRhbHMsIGFuICJvIiB0aGF0IGlzIG5vdCBhIHBlcmZlY3QgY2lyY2xlLCBhbmQgc2hvcnRlbmVkIGFzY2VuZGVycy4gVGhlc2UgbnVhbmNlcyBhaWQgaW4gbGVnaWJpbGl0eSBhbmQgZ2l2ZSBBdmVuaXIgYSBoYXJtb25pb3VzIGFuZCBzZW5zaWJsZSBhcHBlYXJhbmNlIGZvciBib3RoIHRleHRzIGFuZCBoZWFkbGluZXMuIEluIDIwMDQgQWRyaWFuIEZydXRpZ2VyIGFuZCB0aGUgdHlwZSBkaXJlY3RvciBvZiBMaW5vdHlwZSBHbWJIIEFraXJhIEtvYmF5YXNoaSByZXdvcmtlZCB0aGUgQXZlbmlyIGFuZCBjcmVhdGVkIHRoZSBBdmVuaXIgTmV4dCBmb3IgdGhlIFBsYXRpbnVtIENvbGxlY3Rpb24uIEl0IGluY2x1ZGVzIG5ldyBzbWFsbCBjYXBzLCBuZXdseSBkZXNpZ25lZCB0cnVlIGl0YWxpY3MsIGFuZCBhIGNvbXBsZXRlIG5ldyByYW5nZSBvZiBjb25kZW5zZWQgd2VpZ2h0cy4gQXZlbmlyIE5leHQgaXMgYSB2ZXJzYXRpbGUgc2FucyBzZXJpZiBmYW1pbHksIHJlYWR5IGZvciBsYXJnZSBhbmQgY29tcGxleCBwcm9qZWN0cyBmcm9tIGJvb2tzIHRvIHNpZ25hZ2UgdG8gYWR2ZXJ0aXNpbmcuAABoAHQAdABwADoALwAvAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0AAGh0dHA6Ly93d3cubGlub3R5cGUuY29tAABoAHQAdABwADoALwAvAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBmAG8AbgB0AGQAZQBzAGkAZwBuAGUAcgBzAABodHRwOi8vd3d3Lmxpbm90eXBlLmNvbS9mb250ZGVzaWduZXJzAABOAE8AVABJAEYASQBDAEEAVABJAE8ATgAgAE8ARgAgAEwASQBDAEUATgBTAEUAIABBAEcAUgBFAEUATQBFAE4AVAANAAoADQAKAFkAbwB1ACAAaABhAHYAZQAgAG8AYgB0AGEAaQBuAGUAZAAgAHQAaABpAHMAIABmAG8AbgB0ACAAcwBvAGYAdAB3AGEAcgBlACAAZQBpAHQAaABlAHIAIABkAGkAcgBlAGMAdABsAHkAIABmAHIAbwBtACAATABpAG4AbwB0AHkAcABlACAARwBtAGIASAAgAG8AcgAgAHQAbwBnAGUAdABoAGUAcgAgAHcAaQB0AGgAIABzAG8AZgB0AHcAYQByAGUAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABiAHkAIABvAG4AZQAgAG8AZgAgAEwAaQBuAG8AdAB5AHAAZQAnAHMAIABsAGkAYwBlAG4AcwBlAGUAcwAuAA0ACgANAAoAVABoAGkAcwAgAGYAbwBuAHQAIABzAG8AZgB0AHcAYQByAGUAIABpAHMAIABhACAAdgBhAGwAdQBhAGIAbABlACAAYQBzAHMAZQB0ACAAbwBmACAATABpAG4AbwB0AHkAcABlACAARwBtAGIASAAuACAAVQBuAGwAZQBzAHMAIAB5AG8AdQAgAGgAYQB2AGUAIABlAG4AdABlAHIAZQBkACAAaQBuAHQAbwAgAGEAIABzAHAAZQBjAGkAZgBpAGMAIABsAGkAYwBlAG4AcwBlACAAYQBnAHIAZQBlAG0AZQBuAHQAIABnAHIAYQBuAHQAaQBuAGcAIAB5AG8AdQAgAGEAZABkAGkAdABpAG8AbgBhAGwAIAByAGkAZwBoAHQAcwAsACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAgAGYAbwBuAHQAIABzAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAbQBpAHQAZQBkACAAdABvACAAeQBvAHUAcgAgAHcAbwByAGsAcwB0AGEAdABpAG8AbgAgAGYAbwByACAAeQBvAHUAcgAgAG8AdwBuACAAdQBzAGUALgAgAFkAbwB1ACAAbQBhAHkAIABuAG8AdAAgAGMAbwBwAHkAIABvAHIAIABkAGkAcwB0AHIAaQBiAHUAdABlACAAdABoAGkAcwAgAGYAbwBuAHQAIABzAG8AZgB0AHcAYQByAGUALgAgAEkAZgAgAHkAbwB1ACAAaABhAHYAZQAgAGEAbgB5ACAAcQB1AGUAcwB0AGkAbwBuAHMAIAByAGUAZwBhAHIAZABpAG4AZwAgAHkAbwB1AHIAIABsAGkAYwBlAG4AcwBlACAAdABlAHIAbQBzACwAIABwAGwAZQBhAHMAZQAgAHIAZQB2AGkAZQB3ACAAdABoAGUAIABsAGkAYwBlAG4AcwBlACAAYQBnAHIAZQBlAG0AZQBuAHQAIAB5AG8AdQAgAHIAZQBjAGUAaQB2AGUAZAAgAHcAaQB0AGgAIAB0AGgAZQAgAHMAbwBmAHQAdwBhAHIAZQAuAA0ACgANAAoARwBlAG4AZQByAGEAbAAgAGwAaQBjAGUAbgBzAGUAIAB0AGUAcgBtAHMAIABhAG4AZAAgAHUAcwBhAGcAZQAgAHIAaQBnAGgAdABzACAAYwBhAG4AIABiAGUAIAB2AGkAZQB3AGUAZAAgAGEAdAAgAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBsAGkAYwBlAG4AcwBlAC4ADQAKAA0ACgBHAGUAbgBlAHIAZQBsAGwAZQAgAEwAaQB6AGUAbgB6AGIAZQBkAGkAbgBnAHUAbgBnAGUAbgAgAHUAbgBkACAATgB1AHQAegB1AG4AZwBzAHIAZQBjAGgAdABlACAAZgBpAG4AZABlAG4AIABTAGkAZQAgAHUAbgB0AGUAcgAgAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBsAGkAYwBlAG4AcwBlAC4ADQAKAA0ACgBQAG8AdQByACAAcABsAHUAcwAgAGQAJwBpAG4AZgBvAHIAbQBhAHQAaQBvAG4AcwAgAGMAbwBuAGMAZQByAG4AYQBuAHQAIABsAGUAIABjAG8AbgB0AHIAYQB0ACAAZAAnAHUAdABpAGwAaQBzAGEAdABpAG8AbgAgAGQAdQAgAGwAbwBnAGkAYwBpAGUAbAAgAGQAZQAgAHAAbwBsAGkAYwBlAHMALAAgAHYAZQB1AGkAbABsAGUAegAgAGMAbwBuAHMAdQBsAHQAZQByACAAbgBvAHQAcgBlACAAcwBpAHQAZQAgAHcAZQBiACAAdwB3AHcALgBsAGkAbgBvAHQAeQBwAGUALgBjAG8AbQAvAGwAaQBjAGUAbgBzAGUALgANAAoADQAKAEwAaQBuAG8AdAB5AHAAZQAgAEcAbQBiAEgAIABjAGEAbgAgAGIAZQAgAGMAbwBuAHQAYQBjAHQAZQBkACAAYQB0ADoADQAKAA0ACgBUAGUAbAAuADoAIAArADQAOQAoADAAKQA2ADEANwAyACAANAA4ADQALQA0ADEAOAAATk9USUZJQ0FUSU9OIE9GIExJQ0VOU0UgQUdSRUVNRU5UDQoNCllvdSBoYXZlIG9idGFpbmVkIHRoaXMgZm9udCBzb2Z0d2FyZSBlaXRoZXIgZGlyZWN0bHkgZnJvbSBMaW5vdHlwZSBHbWJIIG9yIHRvZ2V0aGVyIHdpdGggc29mdHdhcmUgZGlzdHJpYnV0ZWQgYnkgb25lIG9mIExpbm90eXBlJ3MgbGljZW5zZWVzLg0KDQpUaGlzIGZvbnQgc29mdHdhcmUgaXMgYSB2YWx1YWJsZSBhc3NldCBvZiBMaW5vdHlwZSBHbWJILiBVbmxlc3MgeW91IGhhdmUgZW50ZXJlZCBpbnRvIGEgc3BlY2lmaWMgbGljZW5zZSBhZ3JlZW1lbnQgZ3JhbnRpbmcgeW91IGFkZGl0aW9uYWwgcmlnaHRzLCB5b3VyIHVzZSBvZiB0aGlzIGZvbnQgc29mdHdhcmUgaXMgbGltaXRlZCB0byB5b3VyIHdvcmtzdGF0aW9uIGZvciB5b3VyIG93biB1c2UuIFlvdSBtYXkgbm90IGNvcHkgb3IgZGlzdHJpYnV0ZSB0aGlzIGZvbnQgc29mdHdhcmUuIElmIHlvdSBoYXZlIGFueSBxdWVzdGlvbnMgcmVnYXJkaW5nIHlvdXIgbGljZW5zZSB0ZXJtcywgcGxlYXNlIHJldmlldyB0aGUgbGljZW5zZSBhZ3JlZW1lbnQgeW91IHJlY2VpdmVkIHdpdGggdGhlIHNvZnR3YXJlLg0KDQpHZW5lcmFsIGxpY2Vuc2UgdGVybXMgYW5kIHVzYWdlIHJpZ2h0cyBjYW4gYmUgdmlld2VkIGF0IHd3dy5saW5vdHlwZS5jb20vbGljZW5zZS4NCg0KR2VuZXJlbGxlIExpemVuemJlZGluZ3VuZ2VuIHVuZCBOdXR6dW5nc3JlY2h0ZSBmaW5kZW4gU2llIHVudGVyIHd3dy5saW5vdHlwZS5jb20vbGljZW5zZS4NCg0KUG91ciBwbHVzIGQnaW5mb3JtYXRpb25zIGNvbmNlcm5hbnQgbGUgY29udHJhdCBkJ3V0aWxpc2F0aW9uIGR1IGxvZ2ljaWVsIGRlIHBvbGljZXMsIHZldWlsbGV6IGNvbnN1bHRlciBub3RyZSBzaXRlIHdlYiB3d3cubGlub3R5cGUuY29tL2xpY2Vuc2UuDQoNCkxpbm90eXBlIEdtYkggY2FuIGJlIGNvbnRhY3RlZCBhdDoNCg0KVGVsLjogKzQ5KDApNjE3MiA0ODQtNDE4AABoAHQAdABwADoALwAvAHcAdwB3AC4AbABpAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBsAGkAYwBlAG4AcwBlAABodHRwOi8vd3d3Lmxpbm90eXBlLmNvbS9saWNlbnNlAABBAHYAZQBuAGkAcgAgAE4AZQB4AHQAIABDAHkAcgAAQXZlbmlyIE5leHQgQ3lyAAAAAAIAAAAAAAD/UQAyAAAAAAAAAAAAAAAAAAAAAAAAAAAC2wAAAAEAAgECAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQEDAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQQAigDaAIMAkwDyAPMAjQCXAIgAwwDeAPEAngCqAPUA9AD2AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoAzwDMAM0AzgDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEFAQYBBwEIAQkBCgD9AP4BCwEMAQ0BDgD/AQABDwEQAREBAQESARMBFAEVARYBFwEYARkBGgEbARwBHQD4APkBHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQD6ANcBLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwA4gDjAT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLALAAsQFMAU0BTgFPAVABUQFSAVMBVAFVAPsA/ADkAOUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawC7AWwBbQFuAW8A5gDnAKYBcAFxAXIBcwF0ANgA4QF1ANsA3ADdAOAA2QDfAXYBdwF4AJsBeQF6AXsBfAF9AX4BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjALIAswC2ALcAxAC0ALUAxQCCAMIAhwCrAMYAvgC/AeQAvAHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AIwAnwH7AJgAqACaAJkA7wH8Af0ApQCSAJwApwCPAJQAlQC5Af4B/wIAAgEAwADBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCKgIrAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AjgCOQI6AjsCPAI9Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0CQ1IHdW5pMDBBMAd1bmkwMEFEB0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleApDZG90YWNjZW50CmNkb3RhY2NlbnQGRGNhcm9uBmRjYXJvbgZEY3JvYXQHRW1hY3JvbgdlbWFjcm9uBkVicmV2ZQZlYnJldmUKRWRvdGFjY2VudAplZG90YWNjZW50B0VvZ29uZWsHZW9nb25lawZFY2Fyb24GZWNhcm9uC0djaXJjdW1mbGV4C2djaXJjdW1mbGV4Ckdkb3RhY2NlbnQKZ2RvdGFjY2VudAxHY29tbWFhY2NlbnQMZ2NvbW1hYWNjZW50C0hjaXJjdW1mbGV4C2hjaXJjdW1mbGV4BEhiYXIEaGJhcgZJdGlsZGUGaXRpbGRlB0ltYWNyb24HaW1hY3JvbgZJYnJldmUGaWJyZXZlB0lvZ29uZWsHaW9nb25lawJJSgJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAxLY29tbWFhY2NlbnQMa2NvbW1hYWNjZW50DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlDExjb21tYWFjY2VudAxsY29tbWFhY2NlbnQGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQxOY29tbWFhY2NlbnQMbmNvbW1hYWNjZW50Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQxSY29tbWFhY2NlbnQMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAd1bmkwMTYyB3VuaTAxNjMGVGNhcm9uBnRjYXJvbgRUYmFyBHRiYXIGVXRpbGRlBnV0aWxkZQdVbWFjcm9uB3VtYWNyb24GVWJyZXZlBnVicmV2ZQVVcmluZwV1cmluZw1VaHVuZ2FydW1sYXV0DXVodW5nYXJ1bWxhdXQHVW9nb25lawd1b2dvbmVrC1djaXJjdW1mbGV4C3djaXJjdW1mbGV4C1ljaXJjdW1mbGV4C3ljaXJjdW1mbGV4BlphY3V0ZQZ6YWN1dGUKWmRvdGFjY2VudAp6ZG90YWNjZW50DFNjb21tYWFjY2VudAxzY29tbWFhY2NlbnQHdW5pMDIxQQd1bmkwMjFCCGRvdGxlc3NqB3VuaTAyQzkHdW5pMDM5NAd1bmkwM0E5B3VuaTAzQkMHdW5pMDQwMAd1bmkwNDAxB3VuaTA0MDIHdW5pMDQwMwd1bmkwNDA0B3VuaTA0MDUHdW5pMDQwNgd1bmkwNDA3B3VuaTA0MDgHdW5pMDQwOQd1bmkwNDBBB3VuaTA0MEIHdW5pMDQwQwd1bmkwNDBEB3VuaTA0MEUHdW5pMDQwRgd1bmkwNDEwB3VuaTA0MTEHdW5pMDQxMgd1bmkwNDEzB3VuaTA0MTQHdW5pMDQxNQd1bmkwNDE2B3VuaTA0MTcHdW5pMDQxOAd1bmkwNDE5B3VuaTA0MUEHdW5pMDQxQgd1bmkwNDFDB3VuaTA0MUQHdW5pMDQxRQd1bmkwNDFGB3VuaTA0MjAHdW5pMDQyMQd1bmkwNDIyB3VuaTA0MjMHdW5pMDQyNAd1bmkwNDI1B3VuaTA0MjYHdW5pMDQyNwd1bmkwNDI4B3VuaTA0MjkHdW5pMDQyQQd1bmkwNDJCB3VuaTA0MkMHdW5pMDQyRAd1bmkwNDJFB3VuaTA0MkYHdW5pMDQzMAd1bmkwNDMxB3VuaTA0MzIHdW5pMDQzMwd1bmkwNDM0B3VuaTA0MzUHdW5pMDQzNgd1bmkwNDM3B3VuaTA0MzgHdW5pMDQzOQd1bmkwNDNBB3VuaTA0M0IHdW5pMDQzQwd1bmkwNDNEB3VuaTA0M0UHdW5pMDQzRgd1bmkwNDQwB3VuaTA0NDEHdW5pMDQ0Mgd1bmkwNDQzB3VuaTA0NDQHdW5pMDQ0NQd1bmkwNDQ2B3VuaTA0NDcHdW5pMDQ0OAd1bmkwNDQ5B3VuaTA0NEEHdW5pMDQ0Qgd1bmkwNDRDB3VuaTA0NEQHdW5pMDQ0RQd1bmkwNDRGB3VuaTA0NTAHdW5pMDQ1MQd1bmkwNDUyB3VuaTA0NTMHdW5pMDQ1NAd1bmkwNDU1B3VuaTA0NTYHdW5pMDQ1Nwd1bmkwNDU4B3VuaTA0NTkHdW5pMDQ1QQd1bmkwNDVCB3VuaTA0NUMHdW5pMDQ1RAd1bmkwNDVFB3VuaTA0NUYHdW5pMDQ5MAd1bmkwNDkxBldncmF2ZQZ3Z3JhdmUGV2FjdXRlBndhY3V0ZQlXZGllcmVzaXMJd2RpZXJlc2lzBllncmF2ZQZ5Z3JhdmUHdW5pMjAxMAtpbnRlcnJvYmFuZw16ZXJvLnN1cGVyaW9yDWZvdXIuc3VwZXJpb3INZml2ZS5zdXBlcmlvcgxzaXguc3VwZXJpb3IOc2V2ZW4uc3VwZXJpb3IOZWlnaHQuc3VwZXJpb3INbmluZS5zdXBlcmlvcg16ZXJvLmluZmVyaW9yDG9uZS5pbmZlcmlvcgx0d28uaW5mZXJpb3IOdGhyZWUuaW5mZXJpb3INZm91ci5pbmZlcmlvcg1maXZlLmluZmVyaW9yDHNpeC5pbmZlcmlvcg5zZXZlbi5pbmZlcmlvcg5laWdodC5pbmZlcmlvcg1uaW5lLmluZmVyaW9yBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQd1bmkyMTE2CXB1Ymxpc2hlZAllc3RpbWF0ZWQHdW5pMjIxNQd1bmkyMjE5A2ZfaQNmX2wHdW5pRjhGRgNmX2YFZl9mX2kFZl9mX2wJZ3JhdmUuY2FwCWFjdXRlLmNhcA5jaXJjdW1mbGV4LmNhcAljYXJvbi5jYXAJY2Fyb24uYWx0CXRpbGRlLmNhcAxkaWVyZXNpcy5jYXAKbWFjcm9uLmNhcAlicmV2ZS5jYXAIcmluZy5jYXAQaHVuZ2FydW1sYXV0LmNhcA1kb3RhY2NlbnQuY2FwC2NvbW1hYWNjZW50D2NvbW1hYWNjZW50LmFsdBB6ZXJvLmRlbm9taW5hdG9yD29uZS5kZW5vbWluYXRvcg90d28uZGVub21pbmF0b3IRdGhyZWUuZGVub21pbmF0b3IQZm91ci5kZW5vbWluYXRvchBmaXZlLmRlbm9taW5hdG9yD3NpeC5kZW5vbWluYXRvchFzZXZlbi5kZW5vbWluYXRvchFlaWdodC5kZW5vbWluYXRvchBuaW5lLmRlbm9taW5hdG9yDnplcm8ubnVtZXJhdG9yDW9uZS5udW1lcmF0b3INdHdvLm51bWVyYXRvcg90aHJlZS5udW1lcmF0b3IOZm91ci5udW1lcmF0b3IOZml2ZS5udW1lcmF0b3INc2l4Lm51bWVyYXRvcg9zZXZlbi5udW1lcmF0b3IPZWlnaHQubnVtZXJhdG9yDm5pbmUubnVtZXJhdG9yCGN5cmJyZXZlDGN5cmJyZXZlLmNhcAlleGNsYW0uc2MJZG9sbGFyLnNjCnBlcmNlbnQuc2MMYW1wZXJzYW5kLnNjDHBhcmVubGVmdC5zYw1wYXJlbnJpZ2h0LnNjDmJyYWNrZXRsZWZ0LnNjDGJhY2tzbGFzaC5zYw9icmFja2V0cmlnaHQuc2MMYnJhY2VsZWZ0LnNjCHNsYXNoLnNjDWJyYWNlcmlnaHQuc2MHemVyby5zYwZvbmUuc2MGdHdvLnNjCHRocmVlLnNjB2ZvdXIuc2MHZml2ZS5zYwZzaXguc2MIc2V2ZW4uc2MIZWlnaHQuc2MHbmluZS5zYwtxdWVzdGlvbi5zYwRhLnNjBGIuc2MEYy5zYwRkLnNjBGUuc2MEZi5zYwRnLnNjBGguc2MEaS5zYwRqLnNjBGsuc2MEbC5zYwRtLnNjBG4uc2MEby5zYwRwLnNjBHEuc2MEci5zYwRzLnNjBHQuc2MEdS5zYwR2LnNjBHcuc2MEeC5zYwR5LnNjBHouc2MJYWdyYXZlLnNjCWFhY3V0ZS5zYw5hY2lyY3VtZmxleC5zYwlhdGlsZGUuc2MMYWRpZXJlc2lzLnNjCmFtYWNyb24uc2MJYWJyZXZlLnNjCGFyaW5nLnNjCmFvZ29uZWsuc2MFYWUuc2MJY2FjdXRlLnNjDmNjaXJjdW1mbGV4LnNjCWNjYXJvbi5zYw1jZG90YWNjZW50LnNjC2NjZWRpbGxhLnNjCWRjYXJvbi5zYwlkY3JvYXQuc2MGZXRoLnNjCWVncmF2ZS5zYwllYWN1dGUuc2MOZWNpcmN1bWZsZXguc2MJZWNhcm9uLnNjDGVkaWVyZXNpcy5zYwplbWFjcm9uLnNjCWVicmV2ZS5zYw1lZG90YWNjZW50LnNjCmVvZ29uZWsuc2MOZ2NpcmN1bWZsZXguc2MJZ2JyZXZlLnNjDWdkb3RhY2NlbnQuc2MPZ2NvbW1hYWNjZW50LnNjD2tncmVlbmxhbmRpYy5zYw5oY2lyY3VtZmxleC5zYwdoYmFyLnNjCWlncmF2ZS5zYwlpYWN1dGUuc2MJaWJyZXZlLnNjDmljaXJjdW1mbGV4LnNjCWl0aWxkZS5zYwxpZGllcmVzaXMuc2MKaW1hY3Jvbi5zYw1pZG90YWNjZW50LnNjCmlvZ29uZWsuc2MOamNpcmN1bWZsZXguc2MPa2NvbW1hYWNjZW50LnNjCWxhY3V0ZS5zYwlsY2Fyb24uc2MPbGNvbW1hYWNjZW50LnNjCWxzbGFzaC5zYwdsZG90LnNjCW5hY3V0ZS5zYwluY2Fyb24uc2MJbnRpbGRlLnNjD25jb21tYWFjY2VudC5zYwlvZ3JhdmUuc2MJb2FjdXRlLnNjDm9jaXJjdW1mbGV4LnNjCW90aWxkZS5zYwxvZGllcmVzaXMuc2MKb21hY3Jvbi5zYwlvYnJldmUuc2MQb2h1bmdhcnVtbGF1dC5zYwlvc2xhc2guc2MFb2Uuc2MJcmFjdXRlLnNjCXJjYXJvbi5zYw9yY29tbWFhY2NlbnQuc2MJc2FjdXRlLnNjDnNjaXJjdW1mbGV4LnNjCXNjYXJvbi5zYwtzY2VkaWxsYS5zYw9zY29tbWFhY2NlbnQuc2MJdGNhcm9uLnNjD3Rjb21tYWFjY2VudC5zYwd0YmFyLnNjCHRob3JuLnNjCXVncmF2ZS5zYwl1YWN1dGUuc2MOdWNpcmN1bWZsZXguc2MJdXRpbGRlLnNjDHVkaWVyZXNpcy5zYwp1bWFjcm9uLnNjCXVicmV2ZS5zYwh1cmluZy5zYxB1aHVuZ2FydW1sYXV0LnNjCnVvZ29uZWsuc2MJd2FjdXRlLnNjDndjaXJjdW1mbGV4LnNjDHdkaWVyZXNpcy5zYwl3Z3JhdmUuc2MJeWFjdXRlLnNjDnljaXJjdW1mbGV4LnNjDHlkaWVyZXNpcy5zYwl5Z3JhdmUuc2MJemFjdXRlLnNjCXpjYXJvbi5zYw16ZG90YWNjZW50LnNjBWlqLnNjDWdlcm1hbmRibHMuc2MGZW5nLnNjCGdyYXZlLnNjCGFjdXRlLnNjDWNpcmN1bWZsZXguc2MIY2Fyb24uc2MIdGlsZGUuc2MLZGllcmVzaXMuc2MJbWFjcm9uLnNjCGJyZXZlLnNjB3Jpbmcuc2MPaHVuZ2FydW1sYXV0LnNjDGRvdGFjY2VudC5zYw1leGNsYW1kb3duLnNjD3F1ZXN0aW9uZG93bi5zYwdFdXJvLnNjB2NlbnQuc2MLc3Rlcmxpbmcuc2MJZmxvcmluLnNjBnllbi5zYw5wZXJ0aG91c2FuZC5zYwl6ZXJvLm9udW0Ib25lLm9udW0IdHdvLm9udW0KdGhyZWUub251bQlmb3VyLm9udW0JZml2ZS5vbnVtCHNpeC5vbnVtCnNldmVuLm9udW0KZWlnaHQub251bQluaW5lLm9udW0ObmFwb3N0cm9waGUuc2MOb3JkZmVtaW5pbmUuc2MFZmkuc2MFZmwuc2MAAAAAAf//AAIAAQAAAAwAAABSAAAAAgALAAEACAABAAkACQACAAoAfgABAH8AgAACAIEBCwABAQwBDAACAQ0BywABAcwBzAACAc0B+wABAfwCAAACAgEC2gABAAQAAAACAAAAAAABAAAACgEGAgAAAmN5cmwADmxhdG4AMAAEAAAAAP//AAwAAQADAAQABQAIAAkACgALAAwADQAPABAAIgAFQUZLIABATU9MIABcTkxEIAB2Uk9NIACSVFJLIACwAAD//wAMAAAAAgADAAQABgAIAAoACwAMAA4ADwAQAAD//wALAAIAAwAEAAUACAAKAAsADAAOAA8AEAAA//8ACgADAAQABgAIAAkACgALAAwADwAQAAD//wALAAIAAwAEAAYACAAKAAsADAAOAA8AEAAA//8ADAACAAMABAAGAAgACQAKAAsADAAOAA8AEAAA//8ACwABAAMABAAHAAgACgALAAwADQAPABAAEWFhbHQAaGMyc2MAcGMyc2MAemRub20AhGZyYWMAimxpZ2EAmGxpZ2EAomxpZ2EAqmxudW0AsGxvY2wAtm51bXIAvG9udW0AwnNpbmYAyHNtY3AAznNtY3AA3HN1YnMA6nN1cHMA8AAAAAIAAAABAAAAAwAGAAoADAAAAAMABgAKAAsAAAABABkAAAAFAA0ADgAPABAAEQAAAAMAFQAWABcAAAACABUAFgAAAAEAFgAAAAEAGgAAAAEAAgAAAAEAGAAAAAEACQAAAAEAHAAAAAUAAwAEAAUABgAIAAAABQADAAQABQAGAAcAAAABABsAAAADABIAEwAUACAAQgBKAFIAWgBiAGoAcgB6AIIAigCSAJoAogCqALIAzADUANwA5gDuAPYA/gEGAQ4BFgEeASYBLgE2AT4BRgFOAAEAAAABARQAAwAAAAEDmgABAAAAAQWQAAEAAAABBZYAAQAAAAEHiAABAAAAAQfeAAEAAAABB+wAAQAAAAEH9AABAAAAAQf4AAEAAAABCAIAAQAAAAEIOAABAAAAAQoqAAEAAAABCi4AAQAAAAEKOAAGAAAACgpGCnAKmgrECu4LGAtCC3QLmgvAAAEAAAABC84AAQAAAAEL3AAGAAAAAgvkDAoAAQAAAAEMJgABAAAAAQyIAAEAAAABDKQABAAAAAEMtgAEAAAAAQzQAAQAAAABDPIAAQAAAAENnAABAAAAAQ2kAAEAAAABDawAAQAAAAENtAABAAAAAQ28AAQAAAABDcQABAAAAAEOFAABAAAAAQ4mAAIBSAChAiUCJgInAigCKQIqAjsAbQB9AisCLAItAj0CPgI/AkACQQJCAkMCRQJGAkcCSAJJAksCTAJNAk4CTwJQAlECUgJTAlQCVQIuAjACxQLIAskCywHuAsYCuAJWAlcCWAJZAloCXQJfAmQCaAJpAmoCbAJ4AnkCewJ9AmcCigKMAo0CjgKPApAClAKiAqMCpAKmArACoQKyAlsCXAJeAmACYQJjAmICZQJmAm0CbgJvAnACawJxAnICcwJ0AnYCdwJ8An4CegKAAkQCtwKBAoICdQKDAoUChAKHAoYCiAKLAokCuQKRApICkwKVApYCmAKXApkCmgFDApsCnwKeAqACpQKnAqgCqQKqAqsCrgKxArQCtgK1AsoCnQKfAkUCrwKsAq0CswHuAswB0ALHAdACDwIQAhECEgITAhQCFQIWAhcCGAABAKEABQAIAAkACgAMAA0AIwAlADMAPwBAAEEARgBHAEgASQBKAEsATABOAE8AUABRAFIAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYQBkAGUAZgBoAHAAggCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC7ALwAvQC+AL8AwADBAMIAxADGAMgAygDMAM4A0ADSANQA1gDYANoA3ADeAOAA4gDkAOYA6ADqAOwA7gDwAPIA9AD2APgA+gD7AP0A/wEBAQMBBQEHAQkBCwEOARABEgEUARYBGAEaARwBHgEgASEBJAEmASgBKgEsAS4BMAEyATQBNgE4AToBPQE/AUEBQgFEAUYBRwG4AboBvAG+AcABzAHQAeIB7wIZAhoCGwIcAh0CHgIfAiACIQIiAAEBsgApAFgAcgCMAJgAngCsALoAyADWAOQA8gEAAQ4BHAEqATABNgE8AUABRAFIAU4BVAFaAWABZgFsAXIBeAF+AYQBigGOAZIBlgGaAZ4BogGmAaoBrgAMAAYACwHCAcMBxQHGAcQBxwHNAc4AbgB+AAwABgALAcIBwwHFAcYBxAHHAc0BzgBuAH4ABQARAHABwAHBAe4AAgIvAdAABgIxAs0CGQAUAdEB2AAGAjICzgIaABUAfAHZAAYCMwLPAhsAFgB1AdoABgI0AtACHAAXAHYB2wAGAjUC0QIdABgB0gHcAAYCNgLSAh4AGQHTAd0ABgI3AtMCHwAaAdQB3gAGAjgC1AIgABsB1QHfAAYCOQLVAiEAHAHWAeAABgI6AtYCIgAdAdcB4QACAjwAbQACAkQCfwACAkoAfQABABYAAQAXAAEAFQACAUQCnAACAs0AFAACAs4AFQAC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AZn/7gGl/+YBpv/mAan/5gHA/+wBwf/sAAYBif/0AYv/5gGQ//QBl//sAZr/6gGu//QADAAQ//QAEv/0AYn/9AGL/+YBkP/0AZf/7AGa/+oBn//sAa7/9AHE//QBx//0Acv/9AAKAYYAEgGJAAwBjAAMAZAACgGXABIBmAASAZoACgGiAB4BrgAKAbMAEgAUABD/zgAR/+IAEv/OAYX/9AGJ//QBiv/sAZD/7AGT/+wBlv/sAZcADAGZ/+wBpf/sAab/7AGp//QBrv/sAcD/4gHB/+IBxP/OAcf/zgHL/84ADAAQ/9wAEv/cAYYADAGJ/+4BkP/oAZcADAGZ//QBogASAa7/6AHE/9wBx//cAcv/3AAGAZD/9AGX/+wBmP/0AZr/7AGu//QBs//0AAoAEf/0AYr/6gGT/+oBlv/qAZn/+gGl/+oBpv/qAan/6gHA//QBwf/0AAYAEAAeABIAHgGJAB4BxAAeAccAHgHLAB4ABgGX/+IBmP/sAZz/9AGz/+wBw//iAcb/4gAGAZf/4gGY/+IBnP/0AbP/4gHD/+IBxv/iAAYBif/0AYv/7gGQ//QBl//sAZr/6gGu//QAEAAQ/7oAEf/OABL/ugGF//QBif/0AYr/9AGQ/+wBk//sAZb/9AGXAAoBmf/0AcD/zgHB/84BxP+6Acf/ugHL/7oABQGX/+IBmP/iAZz/9AHD/+IBxv/iAAcAEf/sAYr/5gGT/+YBlv/mAZn/7gHA/+wBwf/sAAsAEP/cABL/3AGGAAwBif/uAZD/6AGXAAwBmf/0AaIAEgHE/9wBx//cAcv/3AARABD/ugAR/84AEv+6AYX/9AGJ//QBiv/0AZD/7AGT/+wBlv/0AZcACgGZ//QBpv/0AcD/zgHB/84BxP+6Acf/ugHL/7oACQFU/+wBV/+mAWD/pgFr/+gBd/+mAXr/6AGL/+wBl//iAZr/9AAeABD/pgAS/6YAJf+4AC7/lAA4ABIAOgASADsAEgA9ABIARf/iAEf/1gBI/9YASf/WAEv/1gBT/9YAVf/WAIn/pgFe/8QBZf+4AWn/xAFw/8QBhf/iAYn/2AGQ/9gBrv/YAcv/pgI8/74CPv/WAkL/1gJK/9YCTP/WAA4AEP+mABL/pgAl/9AARf/EAEf/xABJ/8QAU//EAFf/0AEV//QCPP+yAj7/xAJK/8QCTv/QAl//xAAPAC4AGAA4/7gAOf/oADr/0AA7/+gAPf/EAE4APABa//QAW//0AF3/9AJFAAoCT//iAlH/9AJS//QCVP/cAB4AEP+mABL/pgAl/7gALv+IADgAEgA6ABIAOwASAD0AEgBF/+IAR//WAEj/1gBJ/9YAS//WAFP/1gBV/9YAif+IAV7/xAFl/7gBaf/EAXD/xAGF/+IBif/YAZD/2AGu/9gBy/+mAjz/sgI+/9YCQv/WAkr/1gJM/9YAAwAQ/4gAEv+IAcv/iAAPAC4ADAA4/7gAOf/oADr/0AA7/9wAPf/EAE4APABa//QAW//0AF3/9AJFAAoCT//iAlH/9AJS//QCVP/cAAkABP/iABH/3ABu/9UBwP/cAcH/3AHC/7gBxf+4Acb/uAHN/9AACAAE/+IAOP/cADr/7gA7/+4APf/oAVf/xAFg/8QBd//EAAgABP/iABD/3AAS/9wAOP/EADr/6AA7/+4APf/cAcv/3AANAHH/4gHD/9YBxv/QAef/xAI+//oCQv/6Akr/+gJM//oCT//oAlD/9AJR/+4CUv/0AlT/4gAEABD/9AAS//QCPP/6AlT/+gAHABH/6AI8//oCPv/0Akr/9AJM//QCT//6Al//7AAJABD/6AAS/+gCPP/6AkX/6AJP/+4CU//iAlT/9AJV//QCX//xAAYAEP+4ABL/uAI8/9YCRf++Akr/9AJf/8QACQAR/+gCPP/6Aj7/6AJC/+gCSv/oAk7/+gJQ//QCVP/0Al//+gAQABH/4gBx/8QBwv/iAcP/4gHF/9YBxv/WAef/xAI+/+gCQv/oAkr/6AJM/+gCT//iAlD/9AJR/9YCUv/WAlT/0AAJABD/6AAS/+gCPP/6AkX/6AJP/+4CUf/6AlP/4gJU/+4CVf/uAAQAEP+sABL/rAI8/9wCX/+1AAMCKgAMAi0ADAIwAAwAAgJO//QCT//0AAsAEP++ABH/4gAS/74BwwAYAcYAGAI8/+gCPv/uAkL/7gJF/74CSv/uAl//vwACAjz/9AJf/+cABwAQ/9AAEv/QAcMAGAHGABgCPP/uAkr/+gJf/90ABQAQ/9wAEv/cAcMAGAHGABgCPP/0AAMAEf/0Aj7/4gJK/+IACwAQ/7IAEf/cABL/sgHDABgBxgAYAjz/4gI+/+4CRf+mAkr/7gJM/+4CX/+/AAECSv/uAAECzQAKAAECzv/sAAEC1P/sAAQAEP+wABH/7AAS/7AC0f/sAAECzv/2AAEAigAEAAwAEAARABIAJQAnACgAKQAqACsALgAvADAAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBFAEYASQBKAEsATwBTAFYAWABaAFsAXABdAF8AZABuAH4AggFSAVMBVAFXAVgBXgFfAWABYQFjAWUBZgFnAWgBaQFrAWwBbwFzAXUBdgF3AXgBeQF6AXsBfgF/AYEBggGDAYYBiAGJAYoBiwGPAZMBlQGWAZcBmAGZAZoBmwGeAZ8BoQGiAaMBpQGmAagBrgGvAbEBswG1AbYBwAHBAcIBwwHEAcUBxgHHAcsBzQHOAjwCPQI+Aj8CQQJGAkcCSgJLAkwCTgJPAlACUQJSAlMCVAJVAs0C0QLTAtQC1QAAAAAAAQAAAADUJJkmAAAAAMu8EwIAAAAAy7wTAg"}];
js_Boot.__toStr = ({ }).toString;
var cornerContour_CurveMath_quadStep = 0.03;
format_ttf_MacGlyphNames.names = [".notdef","quotesingle","zero","semicolon","G","V","grave","o","braceright","Udieresis","egrave","oacute","udieresis","registered","infinity","product","exclamdown","guillemotright","emdash","Ydieresis","middot","Edieresis","Ograve","breve","Scaron","thorn","threequarters"];
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
htmlHelper_tools_AnimateTimer.counter = 0;
cornerContourWebGLTest_CornerContourWebGL_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
